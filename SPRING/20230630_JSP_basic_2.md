# JSP 기본 코드 이해

1. JSP 기본 코드 이해
JSP 코드를 작성하는 주된 목적은 웹 브라우저에 보여 줄 HTML 문서를 생성하는 것입니다.
JSP를 사용해서 파일 다운로드를 구현할 수 있고，XMI과 같은 다른 종류의 문서를 응답으로 제공할 수도 있지만,
대부분의 JSP 코드는 HTML을 생성합니다.

<%@ page contentType = "text/html； charset=utf-8" %>
앞서 코드는 JSP 페이지가 생성할 문서가 HTML이며, 문서의 캐릭터 셋(character set : 문자 집합, 문자셋)이
UTF-8 인 것을 나타냅니다.
* 문서의 캐릭터 셋(character set : 문자셋)
캐릭터 셋(character set : 문자 집합, 문자셋)과 캐릭터 인코딩에 대한 내용은
다음의 웹사이트를 참고 바랍니다.
[다음]
1) 한글 인코딩의 이해 1 편 : 한글 인코딩의 역사와 유니코드
   https://d2.naver.com/helloworld/19187
2) 한글 인코딩의 이해 2편 : 유니코드와 Java를 이용한 한글 처리
   https://d2.naver.com/helloworld/76650

<%@ page ... %>를 page 디렉티브라고 하는데, JSP 페이지에 대한 정보를 설정할 때
page 디렉터브를 사용합니다. page 디렉티브를 사용하면 JSP 페이지가 생성할 문서의
타입뿐만 아니라 다양한 정보를 지정할 수 있습니다.


2. JSP 페이지의 구성 요소
JSP 페이지를 작성하려면 다양한 요소들이 필요합니다. JSP 페이지에 대한 정보를
지정해야 하고, 웹 브라우저가 전송한 데이터를 읽어오는 기능이 필요하며,
JSP 페이지에서 사용할 데이터를 생성하는 실행 코드가 필요하고,
웹 브라우저에 문서 데이터를 전송해 주는 기능이 필요합니다.
이처럼 HTML 문서를 생성하기 위해서는 다양한 것들이 필요한데,
이를 위해 JSP는 다음과 같은 것을 제공하고 있습니다.

1) 디렉티브
디렉티브(Directive)는 JSP 페이지에 대한 설정 정보를 지정할 때 사용되며，다음과 같
은 구문을 통해서 디렉티브를 선언할 수 있습니다.
<%@ 디렉터브이름 속성1="값r 속성2="값2"... %>

디렉티브는 '〈%@'으로 시작하고 그 뒤에 디렉터브 이름이 위치합니다. 사용하려는 디렉
티브에 따라서 알맞은 속성이 위치하며, ’%〉'로 디렉티브 선언이 끝납니다.

[JSP가 제공하는 디렉티브]
page = JSP 페이지에 대한 정보를 지정합니다. JSP가 생성하는 문서의 타입,
          출력 버퍼의 크기, 에러 페이지 등 JSP 페이지에서 필요로 하는 정보를 설정합니다.
taglib = JSP 페이지에서 사용할 태그 라이브러리를 지정합니다.
include = JSP 페이지의 특정 영역에 다른 문서를 포함시킵니다.

2) 스크립트 요소
JSP에서 문서의 내용을 동적으로 생성하기 위해 사용되는 것이 스크립트 요소입니다.
스크립트 요소를 사용하면 사용자가 폼에 입력한 정보를 데이터베이스에 저장할 수 있으며,
데이터베이스로부터 게시글 목록을 읽어와 출력할 수도 있습니다.
또한, 스크립트를 사용하면 자바가 제공하는 다양한 기능도 사용할 수 있습니다.
JSP를 스크립트 언어라고 부르는 이유가 바로 막강한 스크립트 코드를 제공해주기 때문입니다.
JSP의 스크립트 요소는 다음과 같이 세 가지가 있다.
① 표현식 (Expression) : 값을 출력합니다.
② 스크립트릿(Scriptlet) : 자바 코드를 실행합니다.
③ 선언부(Declaration) : 자바 메서드(함수)를 만듭니다.

3) 기본 객체
JSP는 웹 어플리케이션 프로그래밍을 하는데 필요한 기능을 제공해주는
'기본 객체(implicit object)'를 제공하고 있습니다.
request, response, session, application, page 등 다수의 기본 객체가 존재하는데,
이들은 각각 요청 파라미터 읽어오기, 응답 결과 전송하기, 세션 처리하기,
웹 어플리케이션 정보 읽어오기 등의 기능을 제공하고 있습니다.

이들 기본 객체를 모든 JSP 페이지에서 사용하는 것은 아니며, request 기본 객체,
session 기본 객체 그리고 response 기본 객체를 주로 사용합니다.

4) 표현 언어(EL : Expression Language)
JSP의 스크립트 요소(스크립트릿과 표현식 그리고 선언부)는 자바 문법을 그대로 사용
할 수 있기 때문에, 자바 언어의 특징을 그대로 사용할 수 있다는 장점이 있습니다.

표현 언어는 '${'와 '}' 사이에 정해진 문법을 따르는 식(expression; 값을 생성하는 코드)
을 입력합니다. JSP는 이 식을 분석해서 알맞은 기능을 실행합니다.
즉, JSP 스크립트 코드를 사용하는 것보다 표현 언어를 사용하는 것이 코드를 간결하고
이해하기 좋게 만들어주기 때문에, 특별한 이유가 없는 한 표현 언어를 주로 사용합니다.

5) 표준 액션 태그와 태그 라이브러리
액션 태그는 jsp 페이지에서 특별한 기능을 제공합니다.
이 액션 태그는 특정한 페이지의 실행 결과를 현재 위치에 포함시킬 때 사용됩니다.
액션 태그는 <jsp:액션태그이름〉의 형태를 갖고 있으며, 액션 태그 종류에 따라서
서로 다른 속성과 값을 갖게 됩니다.

커스텀 태그는 JSP를 확장시켜주는 기능으로서, 액션 태그와 마찬가지로 태그 형태로
기능을 제공합니다. 액션 태그와 차이점이 있다면 커스텀 태그는
개발자가 직접 개발해주어야 한다는 것입니다. 일반적으로 JSP 코드에서
중복되는 것을 모듈화하거나 스크립트 코드를 사용할 때 발생하는 소스 코드의 복잡함을
없애기 위해 커스텀 태그를 사용합니다.

커스텀 태그 중에서 자주 사용하는 것들을 별도로 표준화한 태그 라이브러리가 있는데,
이것이 바로 JSTL(JavaServer Pages Standard Tag Library)입니다. JSTL은 if-else 조건문
그리고 for 구문과 같은 반복 처리를 커스텀 태그를 이용해서 구현할 수 있도록 해 줍니다.
또한，커스텀 태그는 스크립트 코드보다 이해하기 쉽기 때문에 자바 언어에 익숙하지 않더라도
JSTL을 이용해서 어느 정도 논리적인 처리를 수행할 수 있습니다.

3. page 디렉티브
page 디렉티브(Directive)는 JSP 페이지에 대한 설정 정보를 지정할 때 사용됩니다.

[page 디렉 티브의 주요 속성]
contentType = JSP가 생성할 문서의 MIME 타입과 캐릭터 인코딩을 지정합니다. (기본값 = text/html)
import =	JSP 페이지에서 사용할 자바 클래스를 지정합니다.
session = JSP 페이지가 세션을 사용할지의 여부를 지정합니다.
             "true”일 경우 세션을 사용하고 "false"일 경우 세션을 사용하지 않습니다. (기본값 = true)
buffer = JSP 페이지의 출력 버퍼 크기를 지정합니다. ”none"일 경우 출력 버퍼를 사용하지 않으며,
           "8kb"라고 입력한 경우 8킬로바이트 크기의 출력 버퍼를 사용합니다. (기본값 = 	최소 8kb)
autoFlush = 출력 버퍼가 다 찼을 경우 자동으로 버퍼에 있는 데이터를 출력 스트림에 보내고 비울지 여부를 나타냅니다.
                "true"인 경우 버퍼의 내용을 웹 브라우저에 보낸 후 버퍼를 비우며 , "false"인 경우 에러를 발생시킵니다. (기본값 = true)
info = JSP 페이지에 대한 설명을 입력합니다.
errorPage = JSP 페이지를 실행하는 도중에 에러가 발생할 때 보여 줄 페이지를 지정합니다.
isErrorPage = 현재 페이지가 에러가 발생될 때 보여주는 페이지 인지의 여부를 지정합니다.
                  "true”일 경우 에러 페이지이며, "false"일 경우 에러 페이지가 아닙니다. (기본값 = false)
pageEncoding = JSP 페이지 소스 코드의 캐릭터 인코딩을 지정합니다.
isELIgnored = "true”일 경우 표현 언어를 해석하지 않고 문자열로 처리 하며, 'false"일 경우 표현 언어를 지원합니다. (기본값 =  false)
deferredSyntaxAllowedAsLiteral = #{ 문자가 문자열 값으로 사용되는 것을 허용할지의 여부 를 지정합니다. (기본값 = 	false)
trimDirectiveWhitespaces = 출력 결과에서 템플릿 텍스트의 공백 문자를 제거할지의 여부를 지정합니다. (기본값 = false)

page 디렉티브(Directive)에서 주로 사용하는 속성은 contentiype 속성과 import 속성 입니다.

1) contentType 속성과 캐릭터 셋
page 디렉티브의 contenType 속성은 JSP 페이지가 생성할 문서의 타입을 지정합니다.
contenType은 JSP가 생성할 문서의 MIME 타입을 입력합니다. JSP에서 주로 사용하는
MIME 타입은 "text/html"이고 필요에 따라 "text/xml", "application/json" 등의
MIME 타입을 사용하기도 합니다. 참고로, contentType 속성을 설정하지 않을 경우 기본값은 "text/html" 입니다.

* MIME 의미 = Multipurpose Internet Mail Extensions의 약자로서 이메일의 내용을 설명하기 위해
정의 되었습니다. 하지만, 메일뿐만 아니라 HTTP 등의 프로토콜에서도 응답 데이터의 내용을 설명하기 위해서
MIME을 사용하고 있습니다. MIME에 대한 보다 자세한 내용은
http://en.wikipedia.org/wiki/MIME 사이트에 확인할 수 있으며,
등록된 MIME 타입의 목록은 http://www.iana.org/assignments/media-types/index.html에서
확인할 수 있습니다.

contentType 속성의 값 중에서 "； charset=캐릭터 셋'' 부분은 생략할 수 있습니다. 캐릭터 셋 부분을 생략할 경우
기본 캐릭터 셋인 KO-8859-1을 사용하게 됩니다. 우리나라에서는 주로 한글을 포함하는 HTML 문서를 만들어야 하기 때문에,
영어와 서유럽어의 문자만 포함하고 있는 ISO-8859-1로는 한글을 제대로 표현할 수 없습니다.
그래서, 한글을 표현하려면 EUC-KR이나 UTF-8과 같이 한국어를 포함하고 있는 캐릭터 셋을 사용해야 합니다.
참고로 캐릭터 셋을 입력할 때에는 대소문자를 구분하지 않으므로 취향에 따라 대문자나 소문자를 이용해서 입력하면 됩니다.

* 캐릭터 셋 설정 참고 
최근에는 한국어뿐만 아니라 일본어, 영어 등 다국어를 지원하는 국내 서비스가 많습니다.
언어마다 별도의 JSP 코드를 작성하는 것 보다는, 한 개의 JSP 코드로
한국어, 일본어, 영어 페이지를 생성하는 것이 코드 관리 측면에서 유리할 것입니다.
이렇게 한 개의 JSP 코드에서 여러 언어를 처리하려면 다국어를 포함하고 있는 캐릭터 셋인
UTF-8을 사용해야 합니다. 이런 이유로 최근 국내에서 만들어진 많은 사이트가
UTF-8 캐릭터 셋을 이용해서 개발되고 있습니다. 만약에, 캐릭터 셋을 올바르게 입력하지 않으면
응답 결과에서 글자가 올바르게 출력되지 않게 됩니다.

4. JSP 만들고 실행해 보기
[source03 폴더 생성 - invalidCharset.jsp 소스 코딩]

5. import 속성
자바는 클래스의 완전한 이름 대신 단순 이름을 사용하기 위해 import 구문을 사용합니다.
이와 유사하게 JSP는 page 디렉티브의 import 속성을 사용해서
JSP 코드에서 클래스의 단순 이름을 사용할 수 있습니다. import 속성의 사용방법은 다음과 같다.
[다음]
① 한 개의 import 속성에 한 개 타입을 지정
<%@ page import = "java. util. Calendar" %>
<%@ page import = "java.util.Date" %>
② import 속성의 값으로 여러 타입을 지정할 수도 있으며, 이때 각 타입은 콤마로 구분합니다.
<%@ page import = "java.util.Calendar, java.util.Date" %>
패키지 이름 뒤에 별표(’*’)를 사용하면 해당 패키지에 속해 있는
모든 타입을 단순 이름으로 사용할 수 있습니다.
즉, import 속성의 값으로 "java.util.*"을 주면,
JSP 코드에서 Date, Calendar 등 java.util 패키지에 속한 타입을 단순 이름으로 사용할 수 있습니다.

6. JSP 만들고 실행해 보기
[source03 폴더 생성 - useImportCalendar.jsp 소스 코딩]
[source03 폴더 생성 - useFullnameCalendar.jsp 소스 코딩]

7. trimDirectiveWhitespaces 속성을 이용한 공백 처리

앞서, time.jsp를 실행한 뒤 웹 브라우저에서 소스 보기를 해보면
첫 줄에 빈 줄이 생성되는 것을 알 수 있습니다.
이 첫 줄의 공백은 다음의 page 디렉터브가 있던 위치에서 만들어진 것입니다.

JSP 2.0 버전까지는 디렉티브나 스크립트 코드로 인해서 만들어진 줄바꿈 공백 문자를
제거하는 기능이 없었는데, 이 기능이 JSP 2.1 버전부터 새롭게 추가되었습니다.
JSP 2.1 부터 page 디렉티브에 새롭게 추가된 trimDirectiveWhitespaces 속성을 사용하면
불필요하게 생성되는 줄바꿈 공백 문자를 제거할 수 있습니다.
trimDirectiveWhitespaces 속성의 값을 true로 지정하면
디렉터브나 스크립트 코드 위치에서 발생하는 줄바꿈 공백 문자를 제거해줍니다.

[source03 폴더에 있는 time.jsp 파일 안에 다음과 같이 소스 공백 제거 소스 추가해줌]
[source03\time.jsp 소스 수정]
01: 〈%@ page contentType="text/htmI； charset=utf-8” %〉
02: 〈%@ page trimDirectiveWhitespaces="true" %>
~~ 아래 생략 ~~

8. JSP 페이지 인코딩과 pageEncodig 속성
캐릭터 셋을 잘못 지정하면 응답 결과의 글자가 올바르게 출력되지 않게 됩니다.
톰켓과 같은 컨테이너는 JSP 코드를 분석하는 과정에서 어떤 인코딩을 이용해서 코드를 작성했는지 검사하며,
그 결과로 선택한 캐릭터 셋을 이용해서 JSP 페이지의 문자를 읽어오게 됩니다.

* 웹 컨테이너가 JSP 페이지를 읽어올 때 사용할 캐릭터 셋을 결정하는 기본 과정은 다음과 같습니다.
  참고로, 다음의 과정은 JSP 규약에 명시된 과정으로 웹 컨테이너는 위 과정을 최적화 할 수도 있지만
  기본 과정은 위와 비슷합니다. 위 과정을 보면 JSP 파일을 읽을 때는 page 디렉터브의 pageEncoding 속성과
  contentType 속성을 사용해서 캐릭터 인코딩을 결정한다는 것을 알 수 있습니다.
1단계) 파일이 BOM으로 시작하지 않을 경우,
   - 기본 인코딩을 이용해서 파일을 처음부터 읽고, page 디렉티브의 pageEncoding 속성을 검색합니다.
      단, pageEncoding 속성을 찾기 이전에 ASCII 문자 이외의 글자가 포함되어 있지 않은 경우에만 적용됩니다.
   - pageEncoding 속성이 값을 갖고 있다면, 파일을 읽어올 때 속성값을 캐릭터 셋으로 사용합니다.
   - pageEncoding 속성이 없다면, contentType 속성을 검색한다. contentType 속성이 존재하고
      charset을 이용해서 캐릭터 셋을 지정했다면, 파일을 읽어올 때 사용할 캐릭터 셋으로 charset에
      지정한 값을 사용하니다. 단, contentType 속성을 찾기 이전에 ASCII 문자 이외의 글자가
      포함되어 있지 않은 경우에만 적용됩니다.
   - 모두 해당되지 않을 경우 ISO-8859-1 을 캐릭터 셋으로 사용합니다.
2단계) 파일이 BOM으로 시작할 경우,
   - BOM을 이용해서 결정된 인코딩을 이용하여 파일을 읽고, page 디렉티브의 pageEncoding 속성을 검색합니다.
   - 만약 pageEncoding 속성의 값과 B0M을 이용해서 결정된 인코딩이 다르면 에러를 발생시킵니다.
3단계) 1 또는 2 과정을 통해 설정된 캐릭터 셋을 이용해서 JSP 소스 코드를 읽게 됩니다.

* BOM 의미
BOM은 Byte Order Mark의 약자로서 니TF-8, UTF-16, UTF-32와 같은 유니코드 인코딩에서
바이트의 순서가 리틀 엔디언(Little Endian)인지 빅 엔디언(Big Endian)인지의 여부를 알려주는
16비트(2바이트) 값입니다. BOM에 대한보다 상세한 내용은
http://en.wikipedia.org/wiki/Byte_Order_Mark 웹페이지에서 확인할수 있습니다.

pageEncoding 속성에 지정한 인코딩과 contentType 속성에 지정한 인코딩이 서로 다를 수도 있습니다.
예를 들어, JSP 파일은 UTF-8로 작성하고 응답 결과는 EUC-KR로 생성하고 싶다면,
다음과 같이 useUTF8.jsp 소스에서 pageEncoding 속성은 "utf-8"로 지정하고
contentType 속성의 charset은 "euc-kr"로 지정하면 됩니다.

9. JSP 만들고 실행 확인해 보기
[source03 폴더 생성 - useUTF8.jsp 소스 코딩 - 윈도우즈키 + R키 - iexplore
  - http://localhost/source03/useUTF8.jsp 웹 실행 - 마우스 우클릭 - 인코딩 - 한국어(EUC) 선택 확인함]

10. 스크립트 요소 활용하기
1) 스크립트릿 사용하기
스크립트릿(Scriptlet)은 JSP 페이지에서 자바 코드를 실행할 때 사용하는 코드 블록입니다.

* JSP 만들고 실행해 보기
[source03 폴더 생성 - oneToten.jsp 소스 코딩]
[source03 폴더 생성 - sum.jsp 소스 코딩]

11. 표현식
표현식(Expression)은 어떤 값을 출력 결과에 포함시키고자 할 때 사용됩니다.
표현식의 구문은 다음과 같습니다.
<%= 값 %>

* JSP 만들고 실행해 보기
[source03 폴더 생성 - oneToten2.jsp 소스 코딩]

12. 선언부
JSP 페이지의 스크립트릿이나 표현식에서 사용할 수 있는 메서드를 작성할 때에는
선언부(declaration)를 사용합니다.
* 선언부는 다음과 같은 문법 구조를 갖고 있습니다.
<%!
public 리턴타입 메서드이름(파라미터목록) {
자바코드 1;
자바코드 2;
자바코드 n;
return 값;
}
%>

* 선언부의 함수는 자바의 메서드와 동일하며, 각 요소는 다음과 같은 의미를 갖고 있습니다.
- 리턴타입 : 메서드 실행 결과값의 타입을 지정합니다.
- 메서드이름 : 메서드의 이름을 의미합니다.
- 파라미터 목록 : 콤마로 구분된 파라미터의 목록을 지정한다. 파라미터는 메서드 내에서 사용될 변수입니다.
- 자바코드 1-n : 메서드 내에서 실행할 자바 코드가 위치합니다.
- return 값 : 메서드의 실행 결과로 값을 리턴합니다.

* JSP 만들고 실행해 보기
[source03 폴더 생성 - useDecl.jsp 소스 코딩]

표현식뿐만 아니라 스크립트릿에서도 선언부에서 정의한 메서드를 사용할 수 있습니다.

* JSP 만들고 실행해 보기
[source03 폴더 생성 - useDecl2.jsp 소스 코딩]

13. request 기본 객체
request 기본 객체는 JSP 페이지에서 가장 많이 사용되는 기본 객체로서
웹 브라우저의 요청과 관련이 있습니다. 웹 브라우저에 웹 사이트의 주소를 입력하면,
웹 브라우저는 해당 웹 서버에 연결한 후 요청 정보를 전송하는데,
이 요청 정보를 제공하는 것이 바로 request 기본 객체입니다.

1) 클라이언트 정보 및 서버 정보 읽기
request 기본 객체는 웹 브라우저, 즉 클라이언트가 전송한 정보와 서버 정보를 구할 수
있는 메서드를 제공하고 있습니다.
* request 기본 객체의 클라이언트 및 서버 정보 관련 메서드
     메서드명              리턴타입                의미
getRemoteAddr()	       String    웹 서버에 연결한 클라이언트의 IP 주소를 구합니다.
                                          게시판이나 방명록 등에서 글 작성자의 IP 주소가 자동으로 입력되기도 하는데,
                                          이때 입력되는 IP 주소가 바로 이 메서드를 사용하여 구한 것입니다.
getContentLength()       long     클라이언트가 전송한 요청 정보의 길이를 구합니다.
                                          전송된 데이 터의 길이를 알 수 없는 경우 -1 을 리턴합니다.
getCharacterEncoding()  String    클라이언트가 요청 정보를 전송할 때 사용한 캐릭터의 인코딩을 구합니다.
getContentType()	       String    클라이언트가 요청 정보를 전송할 때 사용한 컨텐츠의 타입을 구합니다.
getProtocol()               String    클라이언트가 요청한 프로토콜을 구합니다.
getMethod()	       String    웹 브라우저가 정보를 전송할 때 사용한 방식을 구합니다.
getRequestURI()	       String    웹 브라우저가 요청한 URL에서 경로를 구합니다.
getContextPath()	       String    JSP 페이지가 속한 웹 어플리케이션의 컨텍스트 경로를 구합니다.
getServerName()          String    연결할 때 사용한 서버 이름을 구합니다.
getServerPort()  	       int	       서버가 실행중인 포트 번호를 구합니다.

* JSP 만들고 실행해 보기
[source03 폴더 생성 - requestInfo.jsp 소스 코딩]

2) 요청 파라미터 처리
2-1) HTML 폼과 요청 파라미터
[source03 폴더 생성 - form.jsp 소스 코딩]

2-2) request 기본 객체의 요청 파라미터 관련 메서드
request 기본 객체는 웹 브라우저가 전송한 파라미터를 읽어올 수 있는 메서드를 제공하고 있습니다.
* request 기본 객체의 파라미터 읽기 메서드
        메서드                              리턴 타입              			의미
getParameter(String name)	            String	 	이름이 name인 파라미터의 값을 구합니다.
                                                             	존재 하지 않을 경우 null을 리턴합니다.
getParameterValues( String name)	String[]		이름이 name인 모든 파라미터의 값을 배열로 구합니다.
                                                      		존재하지 않을 경우 null을 리턴합니다.
getParameterNames()	       java.util.Enumeration	웹 브라우저가 전송한 파라미터의 이름 목록을 구합니다.
getParameterMap()	                      java.util.Map	웹 브라우저가 전송한 파라미터의 맵을 구합니다.
                                                                         Map은〈파라미터 이름, 값〉쌍으로 구성 됩니다.

* JSP 만들고 실행해 보기
[source03 폴더 - form.jsp 수정 코딩]

* JSP 만들고 실행해 보기
[source03 폴더 생성 - viewParameter.jsp 소스 코딩]

2-3) GET 방식 전송과 POST 방식 전송
웹 브라우저는 GET 방식과 POST 방식의 두 가지 방식 중 한 가지를 이용해서 파라미터를 전송합니다.
GET 방식과 POST 방식의 차이점은 전송 방식에 있습니다. GET 방식은 요청 URL에 파라미터를 붙여서 전송합니다.

GET 방식은 URL의 경로 뒤에 물음표('?')와 함께 파라미터를 붙여 전송하는데,
이를 쿼리 문자열(query string)이라고 합니다. 쿼리 문자열의 형식은 다음과 같습니다.
[다음]
이름1=값1&이름2=값2&...&이름n=값n

각각의 파라미터는 앰퍼샌드(&) 기호로 구분하며, 파라미터의 이름과 값은 등호기호(=)로 구분합니다.
앞서 address 파라미터의 값이 "%EC%95%84%EC%B0%A8%EA%B3%A1"과 같은 이상한 문자로 표시된 것을 알 수 있습니다.
이렇게 이상한 문자가 출력된 이유는 파라미터 값을 RFC 2396 규약에 정의된 규칙에 따라 인코딩해서 전송하기
때문입니다. 실제로 "%EC%95%84%EC%B0%A8%EA%B3%Al"는 '아차곡' 이라는 값을 UTF-8로 인코딩 한 결과입니다.

* RFC 2396 규약 참고
RFC 2396 규약에 따르면 공백문자(' ')는 '+'로, 알파벳과 숫자는 그대로, 특수문자들은 %HH의 형태로 표시해야 합니다.
RFC 2396 규약에 대한 자세한 내용은 http://www.ietf.org/rfc/rfc2396.txt 웹 사이트에서 확인할 수 있습니다.
GET 방식은 URL의 쿼리 문자열로 전송되기 때문에, 폼을 사용하지 않아도 파라미터를 전송할 수 있습니다.

예를 들어, 웹 브라우저의 주소란에 직접 다음과 같은 URL을 입력해서 실행할 수도 있습니다.
http://localhost:8080/viewParameter.jsp?name=kimheesun&address=seoul&pet=cat

웹 브라우저는 HTTP 프로토콜에 맞춰서 데이터를 전송합니다. HTTP 프로토콜에 따르면
첫 번째 줄은 요청 방식(GET, POST 등)과 URI, 그리고 HTTP 프로토콜 버전을 명시하도록 되어 있습니다.
GET 방식으로 요청 파라미터를 전송하는 경우 파라미터가 URI와 함께 전송되는 것을 확인할 수 있습니다.
URL에 파라미터가 함께 전송되는 GET 방식과 달리 POST 방식은 데이터 영역을 이용해서 파라미터를 전송합니다.

* HTTP 프로토콜에서의 메서드(Method)
앞서 GET 방식과 POST 방식에서 실제로 데이터가 어떻게 전송되는지 살펴봤는데,
HTTP 프로토콜에서는 요청 방식을 표현할 때 '메서드(Method)'라는 용어를 사용합니다.
즉, GET 메서드, POST 메서드와 같이 표현하고 있습니다.


2-4) 요청 파라미터 인코딩
웹 브라우저는 웹 서버에 파라미터를 전송할 때 알맞은 캐릭터 셋을 이용해서 파라미터값을 인코딩합니다.
반대로 웹 서버는 알맞은 캐릭터 셋을 이용해서 웹 브라우저가 전송한 파라미터 데이터를 디코딩합니다.

어떤 캐릭터 셋을 사용할지의 여부는 두 전송 방식-GET 방식과 POST 방식-에 따라 달라집니다.
먼저 POST 방식에서는 입력 폼을 보여주는 응답 화면이 사용하는 캐릭터 셋을 사용합니다.
예를 들어, 응답 결과에서 사용한 캐릭터 셋이 UTF-8이면 UTF-8 캐릭터 셋을 이용해서 파라미터 값을 인코딩합니다.
비슷하게 응답 결과에서 사용한 캐릭터 셋이 EUC-KR이면, EUC-KR 캐릭터 셋을 이용해서 파라미터 값을 인코딩합니다.

* 서블릿 규약 setCharacterEncoding() 메서드 적용 원칙
서블릿 규약에 따르면 setCharacterEncoding() 메서드는 HTTP 프로토콜의 데이터 영역을 인코딩할 때
사용할 캐릭터 셋을 지정합니다. POST 방식은 파라미터를 데이터 영역을 통해서 전달하므로
setCharacterEncoding() 메서드에서 지정한 캐릭터 셋이 적용됩니다. 반면에 GET 방식은 요청 라인에
URI와 함께 쿼리 문자열로 파라미터를 전달하기 때문에 setCharacterEncoding() 메서드에서 지정한
캐릭터 셋이 적용되지 않는 것이 원칙입니다.

3) 요청 헤더 정보의 처리
HTTP 프로토콜은 헤더 정보에 부가적인 정보를 담도록 하고 있습니다.

* request 기본 객체가 제공하는 헤더 관련 메서드
       메서드                     리턴 타입                             의미
getHeader(String name)	String	                 지정한 이름의 헤더 값을 구합니다.
getHeaders(String name)	java.util.Enumeration    지정한 이름의 헤더 목록을 구합니다.
getHeaderNames() 	java.util.Enumeration    모든 헤더의 이름을 구합니다.
getlntHeader(String name)	int	                 지정한 헤더의 값을 정수 값으로 읽어옵니다.
getDateHeader(String name)	long	                 지정한 헤더의 값을 시간 값으로 읽어옵니다.
                                                                 (이때 시간은 1970년 1월 1일 이후로 흘러간
                                                                  1/1000초 단위의 값을 가집니다)

* getHeaderNames() 메서드와 getHeader() 메서드를 사용하는 예제 실습 : JSP 만들고 실행해 보기
[source03 폴더 - viewHeaderList.jsp 소스 코딩]

14. response 기본 객제
response 기본 객체는 request 기본 객체와 반대의 기능을 수행합니다.
request 기본 객체가 웹 브라우저가 전송한 요청 정보를 담고 있다면
response 기본 객체는 웹 브라우저에 보내는 응답 정보를 담고 있습니다.

1) 웹 브라우저에 헤더 정보 전송하기
response 기본 객체는 응답 정보에 헤더를 추가하는 기능을 제합니다.

* response 기본 객체가 제공하는 헤더 추가 메서드
	메서드                                                 의미
addDateHeader(String name, long date) name 헤더에 date를 추가합니다.
                                                   date는 1970년 1 월 1 일 이후 흘러간 시간을 1/1000초 단위로 나타냅니다.
addHeader(String name, String value)	   name 헤더에 value를 값으로 추가합니다.
addlntHeader(String name, int value)	   name 헤더에 정수 값 value를 추가합니다.
setDateHeader(String name, long date)  name 헤더의 값을 date로 지정합니다.
                                                   date는 1970 년 1 월 1 일 이후 흘러간 시간을 1 /1000초 단위로 나타냅니다.
setHeader(String name, String value)	name 헤더의 값을 value로 지정합니다.
setlntHeader(String name, int value)	name 헤더의 값을 정수 값 value로 지정합니다.
containsHeader(String name)	            이름이 name인 헤더를 포함하고 있을 경우 true를 그렇지 않을 경우 false를 리턴합니다.

2) 웹 브라우저 캐시 제어를 위한 응답 헤더 입력
JSP를 비롯한 웹 어플리케이션을 개발하다 보면 새로운 내용을 DB에 추가했는데도
웹브라우저에 출력되는 내용이 바뀌지 않는 경우가 있습니다. 웹 브라우저가 변경된 내역을 출
력하지 않는 이유 중 하나는 웹 브라우저가 서버가 생성한 결과를 출력하지 않고 캐시에
저장된 데이터를 출력하기 때문입니다.

* 캐시(Cache)란?
웹 브라우저가 WAS에 a.jsp의 실행을 요청하고 잠시 뒤에 한 번 더 a.jsp의 실행을 요청했다고 가정해 봅니다.
첫 번째 요청과 두 번째 요청 사이에 a.jsp가 출력한 결과에 차이가 없다면 웹 브라우저는 불필요하게
동일한 응답 결과를 두 번 요청한 셈이 돕니다. 캐시는 이렇게 동일한 데이터를 중복해서 로딩하지
않도록 할 때 사용합니다. 웹 브라우저는 첫 번째 요청 시 응답 결과를 로컬 PC의 임시 보관소인 캐시에 저장합니다.
이후, 동일한 URL에 대한 요청이 있으면 WAS에 접근하지 않고 로컬 PC에 저장된 응답 결과를 사용합니다.
캐시에 보관된 데이터를 사용하는 경우, WAS에 접근하지 않기 때문에 훨씬 빠르게 응답 결과를
웹 브라우저에 출력할 수 있게 됩니다. 따라서 변경이 발생하지 않는 JSP의 응답 결과나
이미자 정적인 HTML 등은 캐시에 보관함으로써 웹 브라우저의 응답 속도를 향상시킬 수 있습니다.

내용이 자주 바뀌지 않는 사이트는 웹 브라우저 캐시를 사용해서 보다 빠른 응답을 제공할 수 있습니다.
하지만, 게시판처럼 내용이 자주 변경되는 사이트는 웹 브라우저 캐시가 적용되면
사용자는 변경된 내용을 확인할 수 없게 됩니다. 예를 들어，게시글 목록이 캐시된 경우,
내가 방금 등록한 게시글이 목록 화면에 보이지 않을 수 있습니다.
HTTP는 특수한 응답 헤더를 통해서 웹 브라우저가 응답 결과를 캐시 할 것인지에 대한
여부를 설정할 수 있습니다. 응답 헤더와 관련된 헤더는 다음과 같습니다.
* response 기본 객체가 제공하는 헤더 추가 메서드
   응답 헤더                                       의미
Cache-Control	HTTP 1.1 버전에서 지원하는 헤더로서, 이 헤더의 값을 "no-cache"로 지정하면
                        웹 브라우저는 응답 결과를 캐시하지 않습니다. "no-cache"로 설정하더라도
                        응답 내용을 캐시 저장소에 보관할 수 있습니다. 예를 들어, "no-cache"를 설정했더라도,
                        웹 브라우저에 따라 뒤로가기 버튼을 클릭하면 캐시 저장소에 보관된 응답 내용을 사용하기도 합니다.
                        응답 결과가 캐시 저장소 자체에 보관되지 않도록 하려면, 이 헤더에 "no-store"를 추가합니다.
Pragma	            HTTP 1.0 버전에서 지원하는 헤더로서, 이 헤더의 값을 "no-cache"로 지정하면
                        웹 브라우저는 응답 결과를 캐시에 저장하지 않는다.
Expires	            HTTP 1.0 버전에서 지원하는 헤더로서, 응답 결과의 만료일을 지정합니다.
                        만료일을 현재 시간보다 이전으로 설정함으로써 캐시에 보관되지 않도록 할 수 있습니다.

최근 웹 브라우저는 HTTP 1.1 버전을 지원하기 때문에 Cache-Control 응답 헤더의값을 "no-cache"로 지정하면
응답 결과를 웹 브라우저가 캐시에 보관하지 않도록 설정 할 수 있습니다.
하지만，HTTP 1.0 버전만 지원하는 웹 브라우저가 존재할 수 있기 때문에,
다음과 같이 Cache-Control 응답 헤더와 Pragma 응답 헤더를 모두 설정해주는 것이 좋습니다.

[다음]
<%
response. setHeader(”Cache-Control", ”no-cache’);
response.addHeaderCCache-Controln, ”no-store");
response. setHeaderf’Pragma”, "’No-cache");
response. setDateHeader("Expires", 1L) ；
%>

위 코드에서 Expires 응답 헤더의 값으로 long 타입 숫자(1Long)를 설정했습니다.
이 값은 1970년 1월 1일 이후를 기준으로 1/1000초 단위로 값을 입력합니다.
웹 브라우저가 응답을 캐시하지 않도록 하고 싶다면 이 값을 현재 시간보다
이전 값으로 지정하면 됩니다. 위 설정에 1L을 값으로 주었는데,
이는 만료일을 1970년 1월 1일 0시 0분 0.001 초로 설정하는 것이므로
HTTP 1.0을 지원하는 웹 브라우저는 응답 결과를 캐시하지 않게 됩니다.

3) 리다이렉트를 이용해서 페이지 이동하기
response 기본 객체에서 많이 사용되는 기능 중 하나는 리다이렉트 기능입니다.
리다이렉트는 웹 서버가 웹 브라우저에게 다른 페이지로 이동하라고 응답하는 기능입니다.
예를 들어，사용자가 로그인에 성공한 후 메인 페이지로 자동으로 이동하는 사이트가 많은데
이렇게 특정 페이지를 실행한 후 지정한 페이지로 이동하길 원할 때 리다이렉트 기능을 사용합니다.
즉, 리다이렉트 기능은 웹 서버 측에서 웹 브라우저에게 어떤 페이지로 이동하라고 지정하는 것입니다.

response 기본 객체는 다음의 메서드를 사용해서 웹 브라우저가 리다이렉트하도록 지시 할 수 있습니다.
• response.send Redirect(String location)
response.sendRedirect() 메서드는 주로 다음과 같은 형태로 사용된다.
〈%@ page import = "java.sql.*" %>
...
<%
   // JSP 페이지에서 필요한 코드를 실행합니다.
   response, send Redirect("이동할 페이지");
%>

* JSP 만들고 실행해 보기 : 로그인 후 첫 페이지로 이동하길 원할 경우
                                 sendRedirect() 메서드를 사용하면 됩니다.
[source03 폴더 생성 - login.jsp 소스 코딩]

* JSP 만들고 실행해 보기 : URLEncoder.encode() 메서드를 사용하여
                                 파라미터 값으로 사용될 문자열을 UTF-8로 인코딩할 수도 있습니다.
[source03 폴더 생성 - redirectEncodingTest.jsp 소스 코딩]


15. JSP 주석
스크립트릿과 선언부의 코드 블록은 자바 코드이므로 다음과 같이 자바의 주석을 사용할 수 있습니다.
[다음]
<%@ page import = "java.util.stream.IntStream" %>
<%
// 자바 8의 스트림을 이용한 1부터 10까지의 합 구하기
int sum = IntStream.range(1, 10).sum();
%>

JSP 코드 자체를 주석 처리하고 싶다면 다음 코드처럼 '〈%--'와 '--%>' 사이에 코드를 위치시키면 됩니다.

〈%-- JSP 파일 안에 JSP 구문에서 주석 표현하는 형식입니다. 자바 구문에서의 주석 표현이 아닙니다. --%>

* JSP 만들고 실행해 보기
[source03 폴더 생성 - jspComment.jsp 소스 코딩]

JSP 페이지를 실행할 때 JSP 주석으로 처리된 부분은 아무 처리도 하지 않으며,
출력 결과에 포함되지도 않게 됩니다.
