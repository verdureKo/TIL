# EL 표현 언어(Expression Language)

표현 언어(Expression Language)는 다른 형태의 스크립트 언어로서
스크립트 요소 중의 하나입니다. 표현 언어(EL)는 표현식(<%= %>)보다
간결하고 편리하기 때문에 많이 사용됩니다.

* 표현 언어란?
표현 언어 (Expression Language)는 JSTL(JSP Standard Tag Library) 1.0 규약에
소개된 내용으로서 JSP 2.0 버전부터 표현 언어가 JSP에 포함 되었고,
JSP 2.1 버전부터 표현 언어와 관련된 규약을 별도 문서로 제공하고 있습니다.
JSP 2.3과 쌍을 이루는 표현 언어 버전은 3.0이며, 우리는 표현 언어 3.0 규약을
기준으로 공부합니다.

표현 언어는 값을 표현하는 데 사용하는 스크립트 언어로, JSP의 스크립트 요소를
보완하는 역할을 합니다. 표현 언어는 다음과 같은 기능을 제공하고 있습니다.
[다음]
• JSP의 네 가지 기본 객체가 제공하는 영역의 속성 사용
• 수치 연산, 관계 연산, 논리 연산자 제공
• 자바 클래스 메서드 호출 기능 제공
• 쿠키, 기본 객체의 속성 등 JSP를 위한 표현 언어의 기본 객체 제공
• 람다식을 이용한 함수 정의와 실행 (EL 3.0부터)
• 스트림 API를 통한 컬렉션 처리 (EL 3.0부터)
• 정적 메서드 실행 (EL 3.0부터)

표현 언어를 사용하면 JSP 표현식을 사용하는 것보다 간결한 코드를 사용해서
값을 출력할 수 있습니다. 예를 들어, 다음 코드는 표현식과 표현 언어를 사용한
코드의 차이를 보여 주고 있습니다.
[다음]
<%-- 표현식 --%>
〈%= member.getAddress().getZipcode() %>
<%-- 표현 언어 --%>
${member.address.zipcode}

위에 코드에서 보듯 표현 언어를 사용한 코드가 더 간결하고 이해가 쉽습니다.
이런 이유로 실제 프로젝트에서는 표현식보다 표현언어(EL)를 사용합니다.
앞으로 표현 언어는 EL로 표현하겠습니다.

1. EL의 구성
EL은 다음과 같이 $와 괄호('{' 와 '}') 그리고 표현식을 사용하여 값을 표현합니다.
${expr}
expr 부분에는 표현 언어가 정의한 문법에 따라 값을 표현하는 식이 옵니다.
EL은 액션 태그나 나중에 배울 JSTL의 속성값으로 사용할 수 있습니다.

액션 태그나 커스텀 태그뿐만 아니라 비스크립트 요소 부분에서도
값을 출력하기 위해 사용할수 있습니다.

EL은 JSP의 스크립트 요소(스크립트릿, 표현식, 선언부)를 제외한
나머지 부분에서 사용될 수 있으며, EL을 통해서 표현식보다 편리하게 값을
출력할 수 있습니다.

JSP 2.1 버전부터는 ${expr} 형식뿐만 아니라 #{expr} 구문을 새롭게 지원하고 있습니다.
#{expr} 형식은 JSF(JavaServer Faces)에서 사용한 EL 구문으로 JSP 2.1 버전에 추가되었습니다. #{expr}과 ${expr}의 가장 큰 차이점은 실제로 EL외 값을 언제 생성하느냐에 있습니다.
${expr} 형식의 EL은 ${expr} 구문을 분석할 때 곧바로 값을 계산합니다. 반면에,
#{expr} 형식은 실제로 값이 사용될 때(미루어) 값을 계산합니다.

이렇게 #{expr} 형식의 EL은 실제로 값이 필요할 때 계산을 수행하기 때문에
Deferred Expression이라고 부릅니다. #{expr}은 곧바로 값이 생성되는 것이 아니기 때문에
JSP의 템플릿 텍스트에서는 사용할 수 없습니다.

JSP에서 #{expr}은 Deferred Expression을 허용하는 태그의 속성에만 위치할 수 있습니다.

[중요] JSP에서 Deferred Expression을 사용하는 경우가 드물기 때문에,
우리는 ${expr} 형식을 중심으로 EL을 공부하겠습니다.

2. EL 기초
EL은 일종의 스크립트 언어로 자료 타입, 수치 연산자, 논리 연산자, 비교 연산자 등을
제공합니다. EL의 언어적인 측면과 규칙들을 숙지하지 않으면 나중에 EL을 사용할 때
버그나 논리적인 오류들을 쉽게 찾을 수 없으므로, EL 기초를 충분히 익히도록 합니다.

1) EL의 데이터 타입과 리터럴
EL은 불리언(Boolean) 타입, 정수 타입, 실수 타입, 문자열 타입 그리고 널 타입의
5가지 타입을 제공하고 있습니다. 각 타입의 표현 방식은 다음과 같습니다.
• 불리 언(Boolean) 타입 : true와 false가 있습니다.
• 정수 타입 : 0〜9로 이루어진 값을 정수로 사용합니다.
   음수의 경우 ’-가 붙습니다. EL에서 정수 타입은 java.lang.Long 타입입니다.
• 실수 타입 : 0~9로 이루어져 있으며，소수점*('.')을 사용할 수 있고,
  3.24e3과 같이 지수형으로 표현 가능합니다.
  실수 타입은 java.lang.Double 타입입니다.
• 문자열 타입 : 따옴표(’또는”)로 둘러싼 문자열. 만약 작은따옴표(')를 사용해서
  표현하는 경우 값에 포함된 작은따옴표는 \'와 같이 \ 기호와 함께 사용해야 합니다.
   \ 기호 자체는 \\로 표시합니다. 문자열은 java.lang.String 타입입니다.
• 널 타입 : null

예를 들어, 다음 코드에서 첫 번째 EL과 두 번째 EL은 각각 정수 타입 값과 실수 타입
값을 출력합니다.
${10}은 정수, ${10.1}은 실수

정수 타입, 실수 타입, 문자열 타입 사이에서의 타입 변환은 정해진 규칙에 따라서
자동으로 이루어집니다.

2) EL의 기본 객체
JSP는 웹 어플리케이션을 구현하는 데 필요한 요청, 응답, 세션 등에 쉽게 접근할 수
있도록 request, response, session 등의 기본 객체를 제공하고 있습니다.
JSP는 EL에서 사용할 수 있는 기본 객체도 제공하고 있습니다. 이 객체를 이용해서
요청 파라미터나 세션 속성값 등을 표현 언어에서 사용할 수 있습니다.

[JSP에서 EL이 사용할 수 있는 기본 객체는 다음과 같습니다]
[다음]
  기본 객체		설명
pageContext	JSP의 page 기본 객체와 동일합니다.
pageScope	pageContext 기본 객체에 저장된 속성의〈속성 , 값〉매핑을 저장한
                        Map 객체입니다.
requestScope	request 기본 객체에 저징된 속성의〈속성 , 값〉매핑을 저장한
                        Map 객체입니다.
sessionScope	session 기본 객체에 저장된 속성의〈속성, 값〉매핑을 저장한
                        Map 객체입니다.
applicationScope	application 기본 객체에 저장된 속성의〈속성, 값〉매핑을 저장한
                        Map 객체입니다.
param	            요청 파라미터의〈파라미터 이름, 값〉매핑을 저장한 Map 객체입니다.
                        파라미터 값 타입은 String이며, request.getParameter(이름)의 결과와
                        동일합니다.
paramValues	요청 파라미터의 〈파라미터 이름，값 배열〉 매핑을 저장한
                        Map 객체입니다. 값 타입은 String[]으로서,
                        request.getParameterValues(이름)의 결과와 동일합니다.
header	            요청 정보의〈헤더 이름, 값 배열〉매핑을 저장한 Map 객체입니다.
                        request.getHeader(이름)의 결과와 동일합니다.
headerValues	요청 정보의〈헤더 이름, 값 배열〉매핑을 저장한 Map 객체입니다.
                        request.getHeaders(이름)의 결과와 동일합니다.
cookie	            <쿠키 이름, Cookie> 매핑을 저장한 Map 객체입니다.
                        request.getCookies()로 구한 Cookie 배열로부터 매핑을 생성합니다.
initParam	            초기화 파라미터의 〈이름, 값〉 매핑을 저장한 Map 객체입니다.
                        application.getlnitParameter(이름)의 결과와 동일합니다.

* JSP 소스 코딩 : EL이 사용할 수 있는 기본 객체 사용 예시
[source09 폴더 안에 useELObject.jsp 소스 코딩함]

3) 객체 접근
EL의 cookie 기본 객체는 다음의 형식으로 사용합니다.
[다음]
${cookie.ID.value}

EL에서 cookie 기본 객체는 〈쿠키 이름, Cookie 객체〉의 매핑 정보를 담고 있는
Map입니다.

EL 언어는 객체에 저장된 값에 접근할 때 다음과 같이 점(.)이나 대괄호([ ])를 사용합니다.
이 두 연산자는 동일한 연산자로서 cookie.name과 cookie['name']은 같은 결과를 리턴합니다.
[다음]
〈표현1〉.〈표현2〉 또는 〈표현1〉［〈표현2〉］

4) 객체 탐색
EL에서 PAGE, REQUEST, SESSION, APPLICATION 영역에 저장된 속성에 접근할 때에는
pageScope, requestScope, sessionScope, applicationScope 기본 객체를 사용합니다.
예를 들어, 다음의 코드는 PAGE 영역에 저장되어 있는 NAME이라는 속성값을 참고합니다.
[다음]
${pageScope.NAME}

영역을 나타내는 EL 기본 객체를 사용하지 않고 이름만 지정하는 경우 EL은 네 개의
영역을 차례대로 검색해서 속성이 존재하는지 확인합니다.

예를 들어，다음의 코드를 살펴봅니다.
[다음]
${name}
이 EL 요소는 PAGE, REQUEST, SESSION 그리고 APPLICATION 영역을 차례대로
검사해서 이름이 name인 속성이 존재하는지 확인하고 존재하는 경우
그 속성의 값을 사용합니다.

5) 수치 연산자
수치 연산자는 다음과 같이 6개가 있습니다.
• + 연산자 : 덧셈
• - 연산자 : 뺄셈
• * 연산자 : 곱셈
• / 또는 div : 나눗셈
• % 또는 mod : 나머지
• - 단항 연산자 : 단항 뻘셈

각 연산자의 의미는 자바 연산자와 완전히 동일하며 나눗셈과 나머지를 구하는
연산자의경우 div와 mod를 각각 추가로 사용할 수 있습니다.

수치 연산자는 정수 타입과 실수 타입에 대해서만 동작한다. 숫자 타입과 객체를
수치연산자와 함께 사용하는 경우 해당 객체를 숫자로 변환한 후에 연산을 수행합니다.
예를들어, 다음 코드를 살펴봅니다.
[다음]
${"10" + 1}
자바에 익숙한 개발자는 "10" + 1은 문자열 "101”이 될 것으로 예상할 것입니다.
하지만, 이 코드의 결과는 숫자 11입니다. EL에서 + 연산자는 수치 연산자이므로
"10"을 숫자로 먼저 변환하고 그다음에 연산을 수행합니다.
따라서, 위 코드 결과는 문자열 "101"이 아니라 숫자 11이 됩니다.

만약 다음과 같이 숫자로 변환할 수 없는 객체와 수치 연산자를 함께 사용하면
에러가 발생한다.
[다음]
${"일" + 10}
쉽게 생각하기에 위 코드는 "일 10" 이라는 문자열을 생성할 것 같지만
EL에서는 "일"을 숫자로 변환할 수 없기 때문에 에러를 발생시킵니다.

[참고]
BigDecimal이나 Biglntege는 보다 정확한 수치 연산을 위해 제공하는 클래스로서
java.math 패키지에 포함되어 있습니다. 예를 들어, 자바에서 1.0 - 0.9의 계산 결과는
0.1 이 아니라 0.1 에 가까운 0.09999999999999998입니다. 이런 일이 벌어지는 이유는
float 타입을 메모리에 보관할 때 사용하는 부동 소수점 방식 때문입니다.
BigDecimal을 사용하면 값 손실 문제없이 실수 연산을 처리할 수 있습니다.

수치 연산의 특징은 값이 null이면 정수 타입 0을 값으로 사용한다는 점입니다.
또, 정수 타입보다 실수 타입이 우선 합니다. 예를 들어, 피연산자 중에
Float, Double, BigDecimal이 있으면 나머지 실수 타입인 Double이나
BigDecimal로 변환한 뒤에 연산을 수행합니다. 비슷하게 실수 타입 값이 없으면
Long 타입이나 Biglnteger로 변환해서 연산을 수행합니다.

6) 비교 연산자
EL이 제공하는 비교 연산자에는 다음과 같이 6가지가 있습니다.
• ==또는 eq
• != 또는 ne
• 〈 또는 It
• 〉 또는 gt
• 〈= 또는 le
• 〉= 또는 ge

숫자의 경우 자바 연산자와 동일한 방법으로 사용됩니다.
문자열을 비교할 경우 String.compareTo() 메서드를 사용합니다.
예를 들어 다음 코드를 살펴봅니다.
${someValue == '2004'}
위 코드는 (someValue.compareTo("2004") == 0)과 같은 의미를 지닙니다.
문자열뿐만 아니라 객체도 compareTo() 메서드를 사용하여 객체가 같은 값을 갖는지를 비교합니다.

7) 논리 연산자
EL은 다음의 세 가지 논리 연산자를 제공합니다.
• && 또는 and
• II 또는 or
• ! 또는 not
이들 세 연산자는 자바 언어의 같은 연산자와 완전히 동일합니다.

8) empty 연산자
empty 연산자는 검사할 객체가 텅 빈 객체인지를 검사하기 위해 사용합니다.
empty 연산자는 다음과 같이 사용합니다.
[다음]
empty 〈값〉

9) 비교 선택 연산자
비교 선택 연산자는 다음과 같습니다.
[다음]
〈수식〉 ? 〈값1〉 : 〈값2〉
〈수식〉의 결과값이 true이면〈값1＞을 리턴하고, false이면〈값2〉를 리턴합니다.

10) 문자열 연결
자바에서 "문자" + "열"의 연산 결과는 String 타입의 "문자열"이지만,
EL에서 "문자"+ "열"의 결과는 에러입니다. 앞서 수치 연산자에서 + 연산자는 피연산자를
숫자로 변환한 뒤에 연산을 수행하는데, "문자"나 "열"은 숫자로 변환할 수 없기 때문에
에러가 발생합니다.

EL 2.2 버전까지는 문자열 연결을 지원하지 않았는데, EL 3.0 버전에 문자열 연결을
위한 += 연산자가 추가되었습니다. 이 연산자를 사용하면 다음과 같이 EL에서
문자열을 연결할 수 있습니다.
[다음]
<% request.setAttribute("title", "JSP 프로그그래밍"); %>
${"문자" += "열” += "연결”} → "문자열 연결”
${ "제목 : " += title } → "제목 : JSP 프로그래밍”

(참고) EL 3.0 버전을 지원하는 JSP 버전은 2.3입니다. JSP 2.2 버전의 경우
EL 2.2 버전을 지원하므로, JSP2.2 버전까지 지원하는 톰켓7 버전을 사용하면
EL 3.0 버전의 문자열 연결 연산자를 사용할 수 없습니다. 즉, 톰캣8 버전부터는
EL 3.0 버전을 지원하는 JSP 버전은 2.3 사용이 가능합니다.

11) 컬렉션
EL 2.2 버전은 컬렉션을 위한 표현 방식을 지원하지 않았습니다. 그래서 List 객체를
생성해서 EL에서 사용하려면 스크립트릿을 이용해서 List 객체를 생성해야 했습니다.
그리고, JSTL을 사용해도 List 객체를 생성하려면 스크립트릿을 사용해야 했습니다.

EL 3.0 버전부터는 EL 식에서 직접 List, Map, Set 타입의 객체를 생성할 수 있게
되었습니다. 예를 들어, 다음과 같이 구현할 수 있게 되었습니다.
[다음]
<c:set var="vals" values="${ [1, 2, 5, 10] }" />
$ {myfunc: sum(vals)}
EL 변수 vals가 필요없다면 다음과 같이 더 간단하게 표현할 수도 있습니다.
[다음]
${myfunc：sum( [1, 2, 5, 10])}

EL에서 List 타입 객체를 생성할 때는 다음 구문을 사용합니다.
[원소1，원소2, 원소3]
대괄호 사이에 List의 각 원소를 콤마로 구분해서 입력하면 됩니다.
List의 각 항목에 접근할 때는 다음과 같이 변수명[인덱스] 형식을 사용합니다.
[다음]
〈c:set var=”vals" values="${ [1, 2, 5, 10]" /〉
${vals[2]} —* 5

Map 타입의 컬렉션 객체를 생성할 때에는 다음 예시와 같은 구문을 사용할 수 있습니다.
[다음]
{'name' : '홍길동’，’age’ : 20}

중괄호 사이에 (키, 값) 쌍을 콤마로 구분해서 지정하고,
키와 값은 콜론(:)으로 구분합니다.

위와 같이 생성한 Map 객체는 EL에서 다음과 같이 사용할 수 있습니다.
[다음]
〈c:set var="mem” value=${ {'name' : '홍길동'，'age' : 20} }" />
$ {mem.name}, $ {mem.age}

Set 타입의 EL 객체를 생성할 때는 {원소 1, 원소2, 원소3} 구문을 사용합니다.
다음은 사용 예시 입니다.
[다음]
<c：set var=”hangul” value="${ {가'，'나'，’다’} }" />
${hangul}

Map과 List를 혼합해서 생성할 수도 있습니다.
예를 들어, 다음과 같이 List와 Map을 섞어서 정의할 수 있습니다.
[다음]
〈c:set var="codes" value=n${ [ {'code' : '001', 'label' : '1번'}, {'code': '001', 'label' : '1번']}" />
${codes[0].code} / ${codes[0],label}}

12) 세미콜론연산자
세미콜론 연산자는 EL 3.0에 추가된 연산자로서, 세미콜론 연산자를 사용하면
다음과 같이 두 개의 식을 붙일 수 있습니다.
[다음]
${ 1 + 1 ； 10 + 10}
위 식의 결과는 20입니다. ${ A ; B}의 EL을 사용하면 A 값은 출력되지 않고
B 값만 출력 합니다.

13) 할당 연산자
앞서 EL 변수를 생성하기 위해 다음의 두 코드 중 하나를 사용했습니다.
[다음]
<% request.setAttribute(”varl"，10L); %>
또는
<c:set var=”var1” value="${10}" />

EL 3.0 버전은 할당 연산자를 제공하는데, 이 연산자를 사용하면 다음과 같은 코드를
사용해서 EL 변수를 생성할 수 있습니다.
[다음]
${ var1 = 10 }

할당 연산자를 사용할 때 주의할 점은 할당 연산자 자체도 출력 결과를 생성한다는
점입니다. 즉, 위 코드를 실행하면 응답 결과로 10이 출력됩니다.
예를 들어, 다음 코드를 실행하면 응답 결과에 "10 10"이 출력됩니다.
[다음]
${varl = 10} ${var1} → 10 10
보통은 할당 연산자의 결과를 응답 결과에 포함시킬 이유가 없는데, 다음과 같이
세미콜론 연산자를 함께 사용하면 할당 연산자의 결과 대신 빈 문자열을 결과로 출력할 수 있습니다.
[다음]
${hangul = ['가', '나'，'다'] ; "] → 응답 결과에 빈 문자열(") 출력.
${hangul[0]} → hangul 변수 값 사용

14) 연산자 우선순위
EL 언어에서 사용되는 연산자들은 우선순위를 갖고 있습니다. 예를 들어, && 연산자보다는
+ 연산자가 먼저 실행되고, I I 연산자보다는 && 연산자가 먼저 실행됩니다.
EL에서 연산자의 우선순위를 정리하면 다음과 같습니다.
[다음]
• [ ] .
• ( )
• 一 (단항) not! empty
• * / div % mod
• + 一
• +=
• <> <= >= lt gt le ge
• == != eq ne
• && and
• II or
• ?：
• ->
• =
• ;
위쪽에 있는 것의 우선순위가 높고 같은 줄에 표시한 연산자의 우선순위는 동일합니다.
우선순위가 같은 경우 실행 순서는 왼쪽에서 오른쪽으로 진행됩니다.

15) 특수 문자처리
EL은 ${expr}이나 #{expr}의 형식을 갖는데, 때론 JSP에서 이런 형식의 문자열을 출력해야
할 때가 있을 것입니다. 이런 경우에는 다음과 같이 역슬래시(\ 또는 ＼) 뒤에
${ 이나 #{ 문자를 위치시키면 됩니다. 표현식 기본 문법은 다음과 같습니다.
[다음]
표현식 기본 문법 : ＼${expr} 또는 ＼#{expr}
위 코드에서 ＼${expr}과 ＼#{expr}은 각각 문자열 "${expr}"과 "#{expr}"을 출력합니다.


