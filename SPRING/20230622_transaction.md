# JPA의 Transaction

트랜잭션은 **DB 데이터들의 `무결성`과 `정합성`을 유지하기 위한 하나의 논리적 개념**이다.

쉽게 표현하자면 **DB의 데이터들을 안전하게 관리**하기 위해서 생겨난 개념이다.

가장 큰 **특징은 여러 개의 SQL이 하나의 트랜잭션에 포함**될 수 있다는 점이다.

이때, 모든 SQL이 성공적으로 수행이 되면 DB에 영구적으로 변경을 반영하지만 SQL 중 단 하나라도 실패한다면 모든 변경을 되돌린다.

JPA는 DB의 이러한 트랜잭션 개념을 사용하여 효율적으로 Entity를 관리하고 있다.

영속성 컨텍스트에 Entity 객체들을 저장했다고 해서 DB에 바로 반영 되지는 않는다.
-> 👀 마치 git의 staging area 마냥 commit 전까지는 뜬개념 삼춘이였다.

DB에서 하나의 트랜잭션에 여러 개의 SQL을 포함하고 있다가 마지막에 영구적으로 변경을 반영하는 것 처럼 JPA에서도 영속성 컨텍스트로 관리하고 있는 변경이 발생한 객체들의 정보를 쓰기 지연 저장소에 전부 가지고 있다가 마지막에 SQL을 한번에 DB에 요청해 변경을 반영한다.

JPA에서 이러한 트랜잭션의 개념을 적용하기 위해서는 EntityManager에서 EntityTransaction을 가져와 트랜잭션을 적용할 수 있다.

- `EntityTransaction et = em.getTransaction();`
  - 해당 코드를 호출하여 EntityTransaction을 가져와 트랜잭션을 관리할 수 있다.
- `et.begin();`
  - 트랜잭션을 시작하는 명령어이다.
- `et.commit();`
  - 트랜잭션의 작업들을 영구적으로 DB에 반영하는 명령어이다.
- `et.rollback();`
  - 오류가 발생했을 때 트랜잭션의 작업을 모두 취소하고, 이전 상태로 되돌리는 명령어이다.

## 영속성 컨텍스트 **Debugging** 해보기

![디버깅](/assets/debugging.PNG)

- 디버깅 포인트를 찍은 후 오른쪽 클릭, Make Default 클릭, Thread 클릭, Done 클릭

![디버깅](/assets/debugging2.PNG)

- 재생버튼 클릭 두번째 디버그 클릭

![디버깅](/assets/debugging3.PNG)

- 영속성 컨텍스트는 내부적으로 캐시 저장소를 가지고 있습니다.
- 우리가 저장하는 Entity 객체들이 1차 캐시 즉, 캐시 저장소에 저장된다고 생각하면됩니다.
- 캐시 저장소는 `Map 자료구조` 형태로 코드 호출 후 em > persistenceContext > entitiesBykey를 확인해보면 key-value 형태로 정보가 저장되어있음을 확인할 수 있습니다.
  - **key**에는 `@Id`로 매핑한 기본 키 즉, `식별자 값`을 저장합니다.
  - **value**에는 해당 Entity 클래스의 `객체`를 저장합니다.
  - 영속성 컨텍스트는 캐시 저장소 **Key**에 저장한 식별자값을 사용하여 Entity 객체를 구분하고 관리합니다.
