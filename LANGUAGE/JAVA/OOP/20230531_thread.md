# 객체지향 프로그래밍_제네릭

## 01. # Chapter 12 : 👷 일꾼 (쓰레드)

## 1. 프로세스와 쓰레드

<aside>
📌 **프로세스 vs 쓰레드**

- **프로세스 :** **운영체제로부터 자원을 할당받는 작업의 단위**
- 쓰**레드 :** **프로세스가 할당받은 자원을 이용하는 실행의 단위**
</aside>

- 프로세스
    - 프로세스 작업 단위
        - 프로세스는 “실행 중인 프로그램”을 의미합니다.
        - 예를들어 우리가 Java 프로그램을 실행시키면 이프로그램은 프로세스라는 이름으로 운영체제 위에서 실행됩니다.
        - 즉, OS 위에서 실행되는 모든 프로그램은 OS가 만들어준 프로세스에서 실행됩니다.
            - 카카오톡, 브라우저, JAVA프로그램 모두 프로세스로 실행되며
            - 크롬 브라우저를 2개 띄우면 크롬 브라우저 프로세스도 2개가 띄워진것 입니다.
        
        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b3353d65-33fc-40d6-a972-c4c7be388ac2/Untitled.png)
        
    - 프로세스 구조
        
        <aside>
        📌 OS가 프로그램 실행을 위한 프로세스를 할당해줄때 프로세스안에 프로그램 Code와 Data 그리고 메모리 영역(Stack, Heap)을 함께 할당해줍니다.
        
        </aside>
        
        1. Code 는 Java main 메소드와 같은 코드를 말합니다.
        2. Data 는 프로그램이 실행중 저장 할 수 있는 저장공간을 의미합니다.
            1. 전역변수, 정적변수(static), 배열등 초기화된 데이터를 저장하는 공간
        3. Memory (메모리 영역)
            - Stack : 지역변수, 매개변수 리턴 변수를 저장하는 공간
            - Heap : 프로그램이 동적으로 필요한 변수를 저장하는 공간 (new(), mallock())
        
        <aside>
        👀 각 프로그램은 프로세스를 통해 Code, Data, Memory (Stack, Heap) 를 OS로부터 할당받습니다.
        
        </aside>
        
        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5786fa99-ed3f-4c5a-8aa9-c08819a7ec33/Untitled.png)
        
- 쓰레드
    
    <aside>
    📌 쓰레드는 프로세스내에서 일하는 일꾼(코드실행의 흐름)이라고 생각하면 됩니다.
    
    </aside>
    
    - 쓰레드의 생성
        - 프로세스가 작업중인 프로그램에서 실행요청이 들어오면 쓰레드(일꾼)을 만들어 명령을 처리하도록 합니다.
    - 쓰레드의 자원
        - 프로세스 안에는 여러 쓰레드(일꾼)들이 있고, 쓰레드들은 실행을 위한 프로세스 내 주소공간이나 메모리공간(Heap)을 공유받습니다.
        - 추가로, 쓰레드(일꾼)들은 각각 명령처리를 위한 자신만의 메모리공간(Stack)도 할당받습니다.
        
        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/97a21f52-8df1-4355-bcbc-525419ab6027/Untitled.png)
        
    - Java 쓰레드
        
        <aside>
        📌 일반 쓰레드와 동일하며 JVM 프로세스 안에서 실행되는 쓰레드를 말합니다.
        
        </aside>
        
        - Java 프로그램을 실행하면 앞서 배운 JVM 프로세스 위에서 실행됩니다.
        - Java 프로그램 쓰레드는 Java Main 쓰레드부터 실행되며 JVM에 의해 실행됩니다.
        
        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/769828df-676b-483a-bf3a-9da938e85ec9/Untitled.png)
        

## 2. 멀티 쓰레드

<aside>
📌 Java는 메인 쓰레드가 main() 메서드를 실행시키면서 시작이 됩니다.

- 메인 쓰레드는 필요에 따라서 작업 쓸레드들을 생성해서 병렬로 코드를 실행 시킬 수 있습니다.
- 즉, Java는 멀티 쓰레드를 지원합니다.
- 싱글 쓰레드와 멀티 쓰레드의 차이에 대해서 좀 더 자세하게 살펴보겠습니다.
</aside>

- 싱글 쓰레드
    
    <aside>
    📌 프로세스 안에서 하나의 쓰레드만 실행되는 것을 말합니다.
    
    </aside>
    
    - Java 프로그램의 경우 `main()` 메서드만 실행시켰을때 이것을 싱글 쓰레드 라고 합니다.
    - 지금까지 코드 스니펫을 통해 실습한 모든 Java프로그램들은 main() 메서드만 실행시켰기 때문에 모두 싱글 쓰레드로 실행되고 있었습니다.
        - Java 프로그램 `main()` 메서드의 쓰레드를 ‘메인 쓰레드’ 라고 부릅니다.
        - JVM 의 메인 쓰레드가 종료되면, JVM 도 같이 종료 됩니다.
- 멀티 쓰레드
    
    <aside>
    📌 프로세스 안에서 여러개의 쓰레드가 실행되는 것을 말합니다.
    
    </aside>
    
    - 하나의 프로세스는 여러개의 실행단위(쓰레드)를 가질 수 있으며 이 쓰레드들은 프로세스의 자원을 공유합니다.
    - Java 프로그램은 메인 쓰레드외에 다른 작업 쓰레드들을 생성하여 여러개의 실행흐름을 만들 수 있습니다.
    - 멀티 쓰레드 장점
        - 여러개의 쓰레드(실행 흐름)을 통해 여러개의 작업을 동시에 할 수 있어서 성능이 좋아집니다.
        - 스택을 제외한 모든 영역에서 메모리를 공유하기 때문에 자원을 보다 효율적으로 사용할 수 있습니다.
        - 응답 쓰레드와 작업 쓰레드를 분리하여 빠르게 응답을 줄 수 있습니다. (비동기)
    - 멀티 쓰레드 단점
        - 동기화 문제가 발생할 수 있습니다.
            - 프로세스의 자원을 공유 하면서 작업을 처리하기 때문에 자원을 서로 사용하려고 하는 충돌이 발생하는 경우를 의미합니다.
        - 교착 상태(데드락)이 발생할 수 있습니다.
            - 둘 이상의 쓰레드가 서로의 자원을 원하는 상태가 되었을 때 서로 작업이 종료되기만을 기다리며 작업을 더 이상 진행하지 못하게 되는 상태를 의미합니다.

## 3. Thread 와 Runnable

<aside>
📌 Java에서 쓰레드를 구현하고 실행하는 방법에 대해서 학습해 보겠습니다.

</aside>

- Thread
    
    <aside>
    📌 Java에서 제공하는 Thread 클래스를 상속받아 쓰레드를 구현해줍니다.
    
    </aside>
    
    ```java
    public class TestThread extends Thread {
    				@Override
    				public void run() {
    							// 쓰레드 수행작업
    				}
    }
    
    ...
    
    TestThread thread = new TestThread(); // 쓰레드 생성
    thread.start() // 쓰레드 실행
    ```
    
    - 여기서 핵심은 `run()` 메서드 입니다.
    - `run()` 메서드에 작성된 코드가 쓰레드가 수행할 작업입니다.
    - [코드 스니펫] Thread
        
        ```java
        public class Main {
            public static void main(String[] args) {
                TestThread thread = new TestThread();
                thread.start();
            }
        }
        
        class TestThread extends Thread {
            @Override
            public void run() {
                for (int i = 0; i <100; i++) {
                    System.out.print("*");
                }
            }
        }
        ```
        
- Runnable
    
    <aside>
    📌 Java에서 제공하는 Runnable 인터페이스를 사용하여 쓰레드를 구현해줍니다.
    
    </aside>
    
    ```java
    public class TestRunnable implements Runnable {
    				@Override
    				public void run() {
    							// 쓰레드 수행작업 
    				}
    }
    
    ...
    
    Runnable run = new TestRunnable();
    Thread thread = new Thread(run); // 쓰레드 생성
    
    thread.start(); // 쓰레드 실행
    ```
    
    - 여기서의  `run()` 메서드도 마찬가지로 쓰레드가 수행할 작업입니다.
    - 그렇다면 Thread를 직접 상속받아 사용하는 방법이 더 간단해 보이는데 왜? Runnable을 사용하여 쓰레드를 구현하는 방법을 소개해드렸을까요?
    - 바로 클래스와 인터페이스 차이 때문입니다. Java는 다중 상속을 지원하지 않습니다.
    - 그렇기 때문에 Thread를 상속 받아 처리하는 방법은 확장성이 매우 떨어집니다.
    - 반대로 Runnable은 인터페이스이기 때문에 다른 필요한 클래스를 상속 받을 수 있습니다.
        - 따라서 확정성에 매우 유리합니다.
    - [코드 스니펫] Runnable
        
        ```java
        public class Main {
            public static void main(String[] args) {
        
                Runnable run = new TestRunnable();
                Thread thread = new Thread(run);
        
                thread.start();
            }
        }
        
        class TestRunnable implements Runnable {
            @Override
            public void run() {
                for (int i = 0; i <100; i++) {
                    System.out.print("$");
                }
            }
        }
        ```
        
- 람다식
    
    <aside>
    📌 Runnable 인터페이스에 람다식을 사용하여 쓰레드를 구현하는 방법을 학습해 보겠습니다.
    
    - 람다식은 다음 Chapter에서 학습하기 때문에 구현 방법에 대해서만 설명드리겠습니다.
    </aside>
    
    ```java
    public class Main {
        public static void main(String[] args) {
            Runnable task = () -> {
                int sum = 0;
                for (int i = 0; i < 50; i++) {
                    sum += i;
                    System.out.println(sum);
                }
                System.out.println(Thread.currentThread().getName() + " 최종 합 : " + sum);
            };
    
            Thread thread1 = new Thread(task);
            thread1.setName("thread1");
            Thread thread2 = new Thread(task);
            thread2.setName("thread2");
    
            thread1.start();
            thread2.start();
        }
    }
    ```
    
    - `run()` 메서드에 작성했던 쓰레드가 수행할 작업을 실행 블록 { } 안에 작성하시면됩니다.
    - `setName()` 메서드는 쓰레드에 이름을 부여할 수 있습니다.
    - `Thread.currentThread().getName()` 은 현재 실행 중인 쓰레드의 이름을 반환합니다.
    
    <aside>
    ⚠️ 앞으로는 빠른 실습을 위해 람다식을 사용하여 쓰레드를 실습하도록 하겠습니다.
    
    </aside>
    
    - [코드 스니펫] Runnable 람다식
        
        ```java
        public class Main {
            public static void main(String[] args) {
                Runnable task = () -> {
                    int sum = 0;
                    for (int i = 0; i < 50; i++) {
                        sum += i;
                        System.out.println(sum);
                    }
                    System.out.println(Thread.currentThread().getName() + " 최종 합 : " + sum);
                };
        
                Thread thread1 = new Thread(task);
                thread1.setName("thread1");
                Thread thread2 = new Thread(task);
                thread2.setName("thread2");
        
                thread1.start();
                thread2.start();
            }
        }
        ```
        
- 실습
    - 싱글 쓰레드
        
        <aside>
        📌 싱글 쓰레드를 실습하겠습니다.
        
        </aside>
        
        ```java
        public class Main {
            public static void main(String[] args) {
                Runnable task = () -> {
                    for (int i = 0; i < 100; i++) {
                        System.out.print("$");
                    }
                };
        
                Thread thread1 = new Thread(task);
                thread1.setName("thread1");
        
                thread1.start();
            }
        }
        ```
        
        - 메인 쓰레드에서 싱글 쓰레드로 하나의 작업을 실행합니다.
        - $ 표시가 순서대로 출력되는 모습을 볼 수 있습니다.
        - [코드 스니펫] 싱글 쓰레드
            
            ```java
            public class Main {
                public static void main(String[] args) {
                    Runnable task = () -> {
                        for (int i = 0; i < 100; i++) {
                            System.out.print("$");
                        }
                    };
            
                    Thread thread1 = new Thread(task);
                    thread1.setName("thread1");
            
                    thread1.start();
                }
            }
            ```
            
    - 멀티 쓰레드
        
        <aside>
        📌 멀티 쓰레드를 실습하겠습니다.
        
        </aside>
        
        ```java
        public class Main {
            public static void main(String[] args) {
                Runnable task = () -> {
                    for (int i = 0; i < 100; i++) {
                        System.out.print("$");
                    }
                };
                Runnable task2 = () -> {
                    for (int i = 0; i < 100; i++) {
                        System.out.print("*");
                    }
                };
        
                Thread thread1 = new Thread(task);
                thread1.setName("thread1");
                Thread thread2 = new Thread(task2);
                thread2.setName("thread2");
        
                thread1.start();
                thread2.start();
            }
        }
        ```
        
        - 메인 쓰레드에서 멀티 쓰레드로 여러개의 작업을 실행 해봅시다.
        - $ 와 * 이 순서가 일정하지 않게 출력되는 모습을 볼 수 있습니다.
        - 여러번 실행해서 보면 순서가 정해져 있지 않아 출력의 형태가 계속해서 변화하는 것을 확인할 수 있습니다.
            - 즉, 2개의 쓰레드는 서로 번갈아가면서 수행됩니다.
        - 여기서 이 두 쓰레드의 실행 순서나 걸리는 시간은 OS의 스케줄러가 처리하기 때문에 알 수 없습니다.
        - [코드 스니펫] 멀티 쓰레드
            
            ```java
            public class Main {
                public static void main(String[] args) {
                    Runnable task = () -> {
                        for (int i = 0; i < 100; i++) {
                            System.out.print("$");
                        }
                    };
                    Runnable task2 = () -> {
                        for (int i = 0; i < 100; i++) {
                            System.out.print("*");
                        }
                    };
            
                    Thread thread1 = new Thread(task);
                    thread1.setName("thread1");
                    Thread thread2 = new Thread(task2);
                    thread2.setName("thread2");
            
                    thread1.start();
                    thread2.start();
                }
            }
            ```
            

## 4. 데몬 쓰레드와 사용자 쓰레드

- 데몬 쓰레드
    
    <aside>
    📌 보이지 않는곳(background) 에서 실행되는 낮은 우선순위를 가진 쓰레드를 말합니다.
    
    - 보조적인 역할을 담당하며 대표적인 데몬 쓰레드로는 메모리 영역을 정리해주는 가비지 컬렉터(GC)가 있습니다.
    </aside>
    
    - 데몬 쓰레드 설정방법
    
    ```java
    public class Main {
        public static void main(String[] args) {
            Runnable demon = () -> {
                for (int i = 0; i < 1000000; i++) {
                    System.out.println("demon");
                }
            };
    
            Thread thread = new Thread(demon);
            thread.setDaemon(true); // true로 설정시 데몬스레드로 실행됨
    
            thread.start();
    
            for (int i = 0; i < 100; i++) {
                System.out.println("task");
            }
        }
    }
    ```
    
    - demon 쓰레드는 우선순위가 낮고 다른 쓰레드가 모두 종료되면 강제 종료 당하기 때문에 `main()` 쓰레드의 task가 100번이 먼저 찍히면 종료되어 1000000번 수행이 되지 않고 종료됩니다.
    - [코드 스니펫] 데몬 쓰레드
        
        ```java
        public class Main {
            public static void main(String[] args) {
                Runnable demon = () -> {
                    for (int i = 0; i < 1000000; i++) {
                        System.out.println("demon");
                    }
                };
        
                Thread thread = new Thread(demon);
                thread.setDaemon(true);
        
                thread.start();
        
                for (int i = 0; i < 100; i++) {
                    System.out.println("task");
                }
            }
        }
        ```
        
- 사용자 쓰레드
    - 보이는 곳(foregorund) 에서 실행되는 높은 우선순위를 가진 쓰레드를 말합니다.
    - 프로그램 기능을 담당하며 대표적인 사용자 쓰레드로는 메인 쓰레드가 있습니다.
    - 사용자 쓰레드 만드는법 : 기존에 만들었던 쓰레드들이 다 사용자 쓰레드 입니다.
    
    <aside>
    ⚠️ JVM 은 사용자 쓰레드의 작업이 끝나면 데몬 쓰레드도 자동으로 종료시켜 버립니다.
    
    </aside>
    

## 5. 쓰레드 우선순위와 쓰레드 그룹

- 쓰레드 우선순위
    
    <aside>
    📌 쓰레드 작업의 중요도에 따라서 쓰레드의 우선순위를 부여할 수 있습니다.
    
    - 작업의 중요도가 높을 때 우선순위를 높게 지정하면 더 많은 작업시간을 부여받아 빠르게 처리될 수 있습니다.
    </aside>
    
    - 쓰레드는 생성될때 우선순위가 정해집니다.
        - 이 우선순위는 우리가 직접 지정하거나 JVM에 의해 지정될 수 있습니다.
    - 우선순위는 아래와 같이 3가지 (최대/최소/보통) 우선순위로 나뉩니다.
        - 최대 우선순위 (MAX_PRIORITY) = 10
        - 최소 우선순위 (MIN_PRIORITY) = 1
        - 보통 우선순위 (NROM_PRIORITY) = 5
            - 기본 값이 보통 우선순위입니다.
        - 더 자세하게 나눈다면 1~10 사이의 숫자로 지정 가능합니다.
        - 이 우선순위의 범위는 OS가 아니라 JVM에서 설정한 우선순위입니다.
    - 스레드 우선순위는 `setPriority()` 메서드로 설정할 수 있습니다.
        
        ```java
        Thread thread1 = new Thread(task1);
        thread1.setPriority(8);
        ```
        
    - `getPriority()` 로 우선순위를 반환하여 확인할 수 있습니다.
        
        ```java
        int threadPriority = thread1.getPriority();
        System.out.println("threadPriority = " + threadPriority);
        ```
        
    
    <aside>
    ⚠️ 우선순위가 높다고 반드시 쓰레드가 먼저 종료되는 것은 아닙니다!
    
    - 확률이 높은거지 반드시 먼저 종료가 되는 것은 아니기 때문에 여러번 실습해 보시면 좋습니다.
    </aside>
    
    - [코드 스니펫] 쓰레드 우선순위
        
        ```java
        public class Main {
            public static void main(String[] args) {
                Runnable task1 = () -> {
                    for (int i = 0; i < 100; i++) {
                        System.out.print("$");
                    }
                };
        
                Runnable task2 = () -> {
                    for (int i = 0; i < 100; i++) {
                        System.out.print("*");
                    }
                };
        
                Thread thread1 = new Thread(task1);
                thread1.setPriority(8);
                int threadPriority = thread1.getPriority();
                System.out.println("threadPriority = " + threadPriority);
        
                Thread thread2 = new Thread(task2);
                thread2.setPriority(2);
        
                thread1.start();
                thread2.start();
            }
        }
        ```
        
- 쓰레드 그룹
    
    <aside>
    📌 서로 관련이 있는 쓰레드들을 그룹으로 묶어서 다룰 수 있습니다.
    
    - 쓰레드들은 기본적으로 그룹에 포함되어 있습니다.
        - JVM 이 시작되면 system 그룹이 생성되고 쓰레드들은 기본적으로 system 그룹에 포함됩니다.
    - 메인 쓰레드는 system 그룹 하위에 있는 main 그룹에 포함됩니다.
    - 모든 쓰레드들은 반드시 하나의 그룹에 포함되어 있어야 합니다.
        - 쓰레드 그룹을 지정받지 못한 쓰레드는 자신을 생성한 부모 쓰레드의 그룹과 우선순위를 상속받게 되는데 우리가 생성하는 쓰레드들은 main 쓰레드 하위에 포함됩니다.
        - 따라서 쓰레드 그룹을 지정하지 않으면 해당 쓰레드는 자동으로 main 그룹에 포함됩니다.
    </aside>
    
    - 쓰레드 그룹 생성
        - ThreadGroup 클래스로 객체를 만들어서 Thread 객체 생성시 첫번째 매개변수로 넣어주면 됩니다.
            
            ```java
            // ThreadGroup 클래스로 객체를 만듭니다.
            ThreadGroup group1 = new ThreadGroup("Group1");
            
            // Thread 객체 생성시 첫번째 매개변수로 넣어줍니다.
            // Thread(ThreadGroup group, Runnable target, String name)
            Thread thread1 = new Thread(group1, task, "Thread 1");
            
            // Thread에 ThreadGroup 이 할당된것을 확인할 수 있습니다.
            System.out.println("Group of thread1 : " + thread1.getThreadGroup().getName());
            ```
            
    - 쓰레드 그룹으로 묶어서 쓰레드 관리
        - ThreadGroup 객체의 interrupt() 메서드를 실행시키면 해당 그룹 쓰레드들이 실행대기 상태로 변경됩니다.
            
            ```java
            // ThreadGroup 클래스로 객체를 만듭니다.
            ThreadGroup group1 = new ThreadGroup("Group1");
            
            // Thread 객체 생성시 첫번째 매개변수로 넣어줍니다.
            // Thread(ThreadGroup group, Runnable target, String name)
            Thread thread1 = new Thread(group1, task, "Thread 1");
            Thread thread2 = new Thread(group1, task, "Thread 2");
            
            // interrupt()는 일시정지 상태인 쓰레드를 실행대기 상태로 만듭니다.
            group1.interrupt();
            ```
            
    - [코드 스니펫] 쓰레드 그룹
        
        ```java
        public class Main {
            public static void main(String[] args) {
                Runnable task = () -> {
                    while (!Thread.currentThread().isInterrupted()) {
                        try {
                            Thread.sleep(1000);
                            System.out.println(Thread.currentThread().getName());
                        } catch (InterruptedException e) {
                            break;
                        }
                    }
                    System.out.println(Thread.currentThread().getName() + " Interrupted");
                };
        
                // ThreadGroup 클래스로 객체를 만듭니다.
                ThreadGroup group1 = new ThreadGroup("Group1");
        
                // Thread 객체 생성시 첫번째 매개변수로 넣어줍니다.
                // Thread(ThreadGroup group, Runnable target, String name)
                Thread thread1 = new Thread(group1, task, "Thread 1");
                Thread thread2 = new Thread(group1, task, "Thread 2");
        
                // Thread에 ThreadGroup 이 할당된것을 확인할 수 있습니다.
                System.out.println("Group of thread1 : " + thread1.getThreadGroup().getName());
                System.out.println("Group of thread2 : " + thread2.getThreadGroup().getName());
        
                thread1.start();
                thread2.start();
        
                try {
                    // 현재 쓰레드를 지정된 시간동안 멈추게 합니다.
                    Thread.sleep(5000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
        
                // interrupt()는 일시정지 상태인 쓰레드를 실행대기 상태로 만듭니다.
                group1.interrupt();
        
            }
        }
        ```
        

## 6. 쓰레드 상태와 제어

<aside>
📌 우리는 동영상을 보거나 음악을 듣고 있을 때 일시정지 후에 다시 보거나 듣기도 하고 중간에 종료 시키기도 합니다. 쓰레드도 마찬가지로 상태가 존재하고 이를 제어를 할 수 있습니다.

</aside>

- 쓰레드 상태
    
    <aside>
    📌 쓰레드의 상태에 대해서 학습해보겠습니다.
    
    </aside>
    
    ![thread.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3c55d71e-361d-4b23-84cf-7561b02f8bf8/thread.png)
    
    - 이처럼 쓰레드는 실행과 대기를 반복하며 `run()` 메서드를 수행합니다.
    - `run()` 메서드가 종료되면 실행이 멈추게 됩니다.
    
    ---
    
    ![thread.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fa57b93f-6ba0-43a7-8e86-995fc1f42c6f/thread.png)
    
    - 음악을 듣다 일시정지를 하는 것과 마찬가지로 쓰레드도 일시정지 상태를 만들 수 있습니다. (2)
    - 일시정지 상태에서는 쓰레드가 실행을 할 수 없는 상태가 됩니다.
    - 쓰레드가 다시 실행 상태로 넘어가기 위해서는 우선 일시정지 상태에서 실행대기 상태로 넘어가야 합니다. (3)
    
    <aside>
    ⚙ 아래는 쓰레드의 상태를 정리한 표입니다.
    
    | 상태 | Enum | 설명 |
    | --- | --- | --- |
    | 객체생성 | NEW | 쓰레드 객체 생성, 아직 start() 메서드 호출 전의 상태 |
    | 실행대기 | RUNNABLE | 실행 상태로 언제든지 갈 수 있는 상태 |
    | 일시정지 | WAITING | 다른 쓰레드가 통지(notify) 할 때까지 기다리는 상태 |
    | 일시정지 | TIMED_WAITING | 주어진 시간 동안 기다리는 상태 |
    | 일시정지 | BLOCKED | 사용하고자 하는 객체의 Lock이 풀릴 때까지 기다리는 상태 |
    | 종료 | TERMINATED | 쓰레드의 작업이 종료된 상태 |
    |  |  |  |
    </aside>
    
- 쓰레드 제어
    
    ---
    
    ![thread.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e9e28a3c-39b4-4b29-8bdc-b19c97e97149/thread.png)
    
    ---
    
    - sleep(), interrupt()
        - sleep()
            
            <aside>
            📌 현재 쓰레드를 지정된 시간동안 멈추게 합니다.
            
            - sleep()은 쓰레드 자기자신에 대해서만 멈추게 할 수 있습니다.
            </aside>
            
            - `sleep()` 사용방법
                
                ```java
                try {
                    Thread.sleep(2000); // 2초
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                ```
                
                - `Thread.sleep(ms);` ms(밀리초) 단위로 설정됩니다.
                - 예외처리를 해야합니다.
                    - sleep 상태에 있는 동안 `interrupt()` 를 만나면 다시 실행되기 때문에 InterruptedException이 발생할 수 있습니다.
                - 특정 쓰레드를 지목해서 멈추게 하는 것은 불가능합니다.
                    
                    ```java
                    public class Main {
                        public static void main(String[] args) {
                            Runnable task = () -> {
                                try {
                                    Thread.sleep(2000);
                                } catch (InterruptedException e) {
                                    e.printStackTrace();
                                }
                                System.out.println("task : " + Thread.currentThread().getName());
                            };
                    
                            Thread thread = new Thread(task, "Thread");
                            thread.start();
                    
                            try {
                                thread.sleep(1000);
                                System.out.println("sleep(1000) : " + Thread.currentThread().getName());
                            } catch (InterruptedException e) {
                                e.printStackTrace();
                            }
                        }
                    }
                    ```
                    
            - [코드 스니펫] sleep()
                
                ```java
                public class Main {
                    public static void main(String[] args) {
                        Runnable task = () -> {
                            try {
                                Thread.sleep(2000);
                            } catch (InterruptedException e) {
                                e.printStackTrace();
                            }
                            System.out.println("task : " + Thread.currentThread().getName());
                        };
                
                        Thread thread = new Thread(task, "Thread");
                        thread.start();
                
                        try {
                            thread.sleep(1000);
                            System.out.println("sleep(1000) : " + Thread.currentThread().getName());
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
                ```
                
        - interrupt()
            
            <aside>
            📌 일시정지 상태인 쓰레드를 실행대기 상태로 만듭니다.
            
            </aside>
            
            - `interrupt()` 분석하기
                - Thread 클래스
                    
                    ```java
                    public class Thread implements Runnable {
                        /* Make sure registerNatives is the first thing <clinit> does. */
                        private static native void registerNatives();
                        static {
                            registerNatives();
                        }
                    
                        private volatile String name;
                        private int priority;
                    
                        /* Whether or not the thread is a daemon thread. */
                        private boolean daemon = false;
                    
                        /* Interrupt state of the thread - read/written directly by JVM */
                        private volatile boolean interrupted;
                    	
                    		...
                    
                    		public void interrupt() {
                            if (this != Thread.currentThread()) {
                                checkAccess();
                    
                                // thread may be blocked in an I/O operation
                                synchronized (blockerLock) {
                                    Interruptible b = blocker;
                                    if (b != null) {
                                        interrupted = true;
                                        interrupt0();  // inform VM of interrupt
                                        b.interrupt(this);
                                        return;
                                    }
                                }
                            }
                            interrupted = true;
                            // inform VM of interrupt
                            interrupt0();
                        }
                    
                    		...
                    
                    		public boolean isInterrupted() {
                            return interrupted;
                        }
                    }
                    ```
                    
                - Thread 클래스 내부에 interrupted 되었는지를 체크하는 boolean 변수가 존재합니다.
                - 쓰레드가 `start()` 된 후 동작하다 `interrupt()`를 만나 실행하면 interrupted 상태가 true가 됩니다.
                - `isInterrupted()` 메서드를 사용하여 상태값을 확인할 수 있습니다.
            - `sleep()` 실행 중 `interrupt()`가 실행되면 예외가 발생합니다.
                
                ```java
                public class Main {
                    public static void main(String[] args) {
                        Runnable task = () -> {
                            try {
                                Thread.sleep(1000);
                                System.out.println(Thread.currentThread().getName());
                            } catch (InterruptedException e) {
                                e.printStackTrace();
                            }
                            System.out.println("task : " + Thread.currentThread().getName());
                        };
                
                        Thread thread = new Thread(task, "Thread");
                        thread.start();
                
                        thread.interrupt();
                
                        System.out.println("thread.isInterrupted() = " + thread.isInterrupted());
                
                    }
                }
                ```
                
                - [코드 스니펫] interrupt() 오류발생
                    
                    ```java
                    public class Main {
                        public static void main(String[] args) {
                            Runnable task = () -> {
                                try {
                                    Thread.sleep(1000);
                                    System.out.println(Thread.currentThread().getName());
                                } catch (InterruptedException e) {
                                    e.printStackTrace();
                                }
                                System.out.println("task : " + Thread.currentThread().getName());
                            };
                    
                            Thread thread = new Thread(task, "Thread");
                            thread.start();
                    
                            thread.interrupt();
                    
                            System.out.println("thread.isInterrupted() = " + thread.isInterrupted());
                    
                        }
                    }
                    ```
                    
            - `!Thread.currentThread().isInterrupted()` 로 interrupted 상태를 체크해서 처리하면 오류를 방지할 수 있습니다.
                
                ```java
                public class Main {
                    public static void main(String[] args) {
                        Runnable task = () -> {
                            while (!Thread.currentThread().isInterrupted()) {
                                try {
                                    Thread.sleep(1000);
                                    System.out.println(Thread.currentThread().getName());
                                } catch (InterruptedException e) {
                                    break;
                                }
                            }
                            System.out.println("task : " + Thread.currentThread().getName());
                        };
                
                        Thread thread = new Thread(task, "Thread");
                        thread.start();
                
                        thread.interrupt();
                
                        System.out.println("thread.isInterrupted() = " + thread.isInterrupted());
                        
                    }
                }
                ```
                
                - [코드 스니펫] interrupt() 예외처리
                    
                    ```java
                    public class Main {
                        public static void main(String[] args) {
                            Runnable task = () -> {
                                while (!Thread.currentThread().isInterrupted()) {
                                    try {
                                        Thread.sleep(1000);
                                        System.out.println(Thread.currentThread().getName());
                                    } catch (InterruptedException e) {
                                        break;
                                    }
                                }
                                System.out.println("task : " + Thread.currentThread().getName());
                            };
                    
                            Thread thread = new Thread(task, "Thread");
                            thread.start();
                    
                            thread.interrupt();
                    
                            System.out.println("thread.isInterrupted() = " + thread.isInterrupted());
                            
                        }
                    }
                    ```
                    
    - join(), yield()
        - jon()
            
            <aside>
            📌 정해진 시간동안 지정한 쓰레드가 작업하는 것을 기다립니다.
            
            - 시간을 지정하지 않았을 때는 지정한 쓰레드의 작업이 끝날 때까지 기다립니다.
            </aside>
            
            - `join()` 사용방법
                
                ```java
                Thread thread = new Thread(task, "thread");
                
                thread.start();
                
                try {
                    thread.join();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                ```
                
                - `Thread.sleep(ms);` ms(밀리초) 단위로 설정됩니다.
                - 예외처리를 해야합니다.
                    - `interrupt()` 를 만나면 기다리는 것을 멈추기 때문에 InterruptedException이 발생할 수 있습니다.
                - 시간을 지정하지 않았기 때문에 thread가 작업을 끝낼 때까지 main 쓰레드는 기다리게됩니다.
                - 예제를 통해서 좀 더 자세하게 살펴보겠습니다.
                - 예제
                    - [코드 스니펫] join()
                        
                        ```java
                        public class Main {
                            public static void main(String[] args) {
                                Runnable task = () -> {
                                    try {
                                        Thread.sleep(5000); // 5초
                                    } catch (InterruptedException e) {
                                        e.printStackTrace();
                                    }
                                };
                        
                                Thread thread = new Thread(task, "thread");
                        
                                thread.start();
                        
                                long start = System.currentTimeMillis();
                        
                                try {
                                    thread.join();
                        
                                } catch (InterruptedException e) {
                                    e.printStackTrace();
                                }
                        
                                // thread 의 소요시간인 5000ms 동안 main 쓰레드가 기다렸기 때문에 5000이상이 출력됩니다.
                                System.out.println("소요시간 = " + (System.currentTimeMillis() - start));
                            }
                        }
                        ```
                        
        - yield()
            
            <aside>
            📌 남은 시간을 다음 쓰레드에게 양보하고 쓰레드 자신은 실행대기 상태가 됩니다.
            
            </aside>
            
            - `yield()` 사용방법
                
                ```java
                public class Main {
                    public static void main(String[] args) {
                        Runnable task = () -> {
                            try {
                                for (int i = 0; i < 10; i++) {
                                    Thread.sleep(1000);
                                    System.out.println(Thread.currentThread().getName());
                                }
                            } catch (InterruptedException e) {
                                Thread.yield();
                            }
                        };
                
                        Thread thread1 = new Thread(task, "thread1");
                        Thread thread2 = new Thread(task, "thread2");
                
                        thread1.start();
                        thread2.start();
                
                        try {
                            Thread.sleep(5000);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                
                        thread1.interrupt();
                
                    }
                }
                ```
                
                - thread1과 thread2가 같이 1초에 한번씩 출력되다가 5초뒤에 thread1에서 InterruptedException이 발생하면서 `Thread.yield();` 이 실행되어 thread1은 실행대기 상태로 변경되면서 남은 시간은 thread2에게 리소스가 양보됩니다.
            - [코드 스니펫] yield()
                
                ```java
                public class Main {
                    public static void main(String[] args) {
                        Runnable task = () -> {
                            try {
                                for (int i = 0; i < 10; i++) {
                                    Thread.sleep(1000);
                                    System.out.println(Thread.currentThread().getName());
                                }
                            } catch (InterruptedException e) {
                                Thread.yield();
                            }
                        };
                
                        Thread thread1 = new Thread(task, "thread1");
                        Thread thread2 = new Thread(task, "thread2");
                
                        thread1.start();
                        thread2.start();
                
                        try {
                            Thread.sleep(5000);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                
                        thread1.interrupt();
                
                    }
                }
                ```
                
            
    - synchronized
        
        <aside>
        📌 멀티 쓰레드의 경우 여러 쓰레드가 한 프로세스의 자원을 공유해서 작업하기 때문에 서로에게 영향을 줄 수 있습니다. 이로인해서 장애나 버그가 발생할 수 있습니다.
        
        - 이러한 일을 방지하기 위해 한 쓰레드가 진행중인 작업을 다른 쓰레드가 침범하지 못하도록 막는 것을 '쓰레드 동기화(Synchronization)'라고 합니다.
        - 동기화를 하려면 다른 쓰레드의 침범을 막아야하는 코드들을 ‘임계영역’으로 설정하면 됩니다.
        - 임계영역에는 Lock을 가진 단 하나의 쓰레드만 출입이 가능합니다.
            - 즉, 임계영역은 한번에 한 쓰레드만 사용이 가능합니다.
        </aside>
        
        - `synchronized` 를 사용한 동기화
            - 실행할 메서드 또는 실행할 코드 묶음 앞에 synchronized 를 붙여서 임계영역을 지정하여 다른 쓰레드의 침범을 막을 수 있습니다. (침범을 막다. =  Lock을 걸다.)
            - 임계영역 지정
                1. 메서드 전체를 임계영역으로 지정합니다.
                    
                    ```java
                    public synchronized void asyncSum() {
                    	  ...침범을 막아야하는 코드...
                    }
                    ```
                    
                2. 특정 영역을 임계영역으로 지정합니다.
                    
                    ```java
                    synchronized(해당 객체의 참조변수) {
                    		...침범을 막아야하는 코드...
                    }
                    ```
                    
        - `synchronized` 사용방법
            - `synchronized` 없을 때
                
                ```java
                public class Main {
                    public static void main(String[] args) {
                        AppleStore appleStore = new AppleStore();
                
                        Runnable task = () -> {
                            while (appleStore.getStoredApple() > 0) {
                                appleStore.eatApple();
                                System.out.println("남은 사과의 수 = " + appleStore.getStoredApple());
                            }
                
                        };
                
                        for (int i = 0; i < 3; i++) {
                            new Thread(task).start();
                        }
                    }
                }
                
                class AppleStore {
                    private int storedApple = 10;
                
                    public int getStoredApple() {
                        return storedApple;
                    }
                
                    public void eatApple() {
                        if (storedApple > 0) {
                            try {
                                Thread.sleep(1000);
                            } catch (InterruptedException e) {
                                e.printStackTrace();
                            }
                            storedApple -= 1;
                        }
                    }
                }
                ```
                
                - 남은 사과의 수가 뒤죽박죽 출력될뿐만 아니라 없는 사과를 먹는 경우도 발생합니다.
                - [코드 스니펫] none synchronized
                    
                    ```java
                    public class Main {
                        public static void main(String[] args) {
                            AppleStore appleStore = new AppleStore();
                    
                            Runnable task = () -> {
                                while (appleStore.getStoredApple() > 0) {
                                    appleStore.eatApple();
                                    System.out.println("남은 사과의 수 = " + appleStore.getStoredApple());
                                }
                    
                            };
                    
                            for (int i = 0; i < 3; i++) {
                                new Thread(task).start();
                            }
                        }
                    }
                    
                    class AppleStore {
                        private int storedApple = 10;
                    
                        public int getStoredApple() {
                            return storedApple;
                        }
                    
                        public void eatApple() {
                            if (storedApple > 0) {
                                try {
                                    Thread.sleep(1000);
                                } catch (InterruptedException e) {
                                    e.printStackTrace();
                                }
                                storedApple -= 1;
                            }
                        }
                    }
                    ```
                    
            - `synchronized` 있을 때
                
                ```java
                public class Main {
                    public static void main(String[] args) {
                        AppleStore appleStore = new AppleStore();
                
                        Runnable task = () -> {
                            while (appleStore.getStoredApple() > 0) {
                                appleStore.eatApple();
                                System.out.println("남은 사과의 수 = " + appleStore.getStoredApple());
                            }
                
                        };
                
                        for (int i = 0; i < 3; i++) {
                            new Thread(task).start();
                        }
                    }
                }
                
                class AppleStore {
                    private int storedApple = 10;
                
                    public int getStoredApple() {
                        return storedApple;
                    }
                
                    public void eatApple() {
                        synchronized (this) {
                            if(storedApple > 0) {
                                try {
                                    Thread.sleep(1000);
                                } catch (InterruptedException e) {
                                    e.printStackTrace();
                                }
                                storedApple -= 1;
                            }
                        }
                    }
                }
                ```
                
                - 사과를 순서대로 잘 먹는 것을 확인할 수 있습니다.
                - [코드 스니펫] synchronized
                    
                    ```java
                    public class Main {
                        public static void main(String[] args) {
                            AppleStore appleStore = new AppleStore();
                    
                            Runnable task = () -> {
                                while (appleStore.getStoredApple() > 0) {
                                    appleStore.eatApple();
                                    System.out.println("남은 사과의 수 = " + appleStore.getStoredApple());
                                }
                    
                            };
                    
                            for (int i = 0; i < 3; i++) {
                                new Thread(task).start();
                            }
                        }
                    }
                    
                    class AppleStore {
                        private int storedApple = 10;
                    
                        public int getStoredApple() {
                            return storedApple;
                        }
                    
                        public void eatApple() {
                            synchronized (this) {
                                if(storedApple > 0) {
                                    try {
                                        Thread.sleep(1000);
                                    } catch (InterruptedException e) {
                                        e.printStackTrace();
                                    }
                                    storedApple -= 1;
                                }
                            }
                        }
                    }
                    ```
                    
    - wait(), notify()
        
        <aside>
        📌 침범을 막은 코드를 수행하다가 작업을 더 이상 진행할 상황이 아니면, `wait()` 을 호출하여 쓰레드가 Lock을 반납하고 기다리게 할 수 있습니다.
        
        - 그럼 다른 쓰레드가 락을 얻어 해당 객체에 대한 작업을 수행 할 수 있게 되고,
        - 추후에 작업을 진행할 수 있는 상황이 되면 `notify()`를 호출해서,
        - 작업을 중단했던 쓰레드가 다시 Lock을 얻어 진행할 수 있게 됩니다.
        </aside>
        
        1. **`wait()`**
            
            실행 중이던 쓰레드는 해당 객체의 대기실(waiting pool)에서 통지를 기다립니다.
            
        2. **`notify()`**
            
            해당 객체의 대기실(waiting pool)에 있는 모든 쓰레드 중에서 임의의 쓰레드만 통지를 받습니다.
            
        - 예제를 통해서 사용방법에 대해 학습하겠습니다.
            - [코드 스니펫] wait() & notify()
                
                ```java
                public class Main {
                    public static String[] itemList = {
                            "MacBook", "IPhone", "AirPods", "iMac", "Mac mini"
                    };
                    public static AppleStore appleStore = new AppleStore();
                    public static final int MAX_ITEM = 5;
                
                    public static void main(String[] args) {
                
                        // 가게 점원
                        Runnable StoreClerk = () -> {
                                while (true) {
                                    int randomItem = (int) (Math.random() * MAX_ITEM);
                                    appleStore.restock(itemList[randomItem]);
                                    try {
                                        Thread.sleep(50);
                                    } catch (InterruptedException ignored) {
                                    }
                                }
                        };
                
                        // 고객
                        Runnable Customer = () -> {
                                while (true) {
                                    try {
                                        Thread.sleep(77);
                                    } catch (InterruptedException ignored) {
                                    }
                
                                    int randomItem = (int) (Math.random() * MAX_ITEM);
                                    appleStore.sale(itemList[randomItem]);
                                    System.out.println(Thread.currentThread().getName() + " Purchase Item " + itemList[randomItem]);
                                }
                        };
                
                        new Thread(StoreClerk, "StoreClerk").start();
                        new Thread(Customer, "Customer1").start();
                        new Thread(Customer, "Customer2").start();
                
                    }
                }
                
                class AppleStore {
                    private List<String> inventory = new ArrayList<>();
                
                    public void restock(String item) {
                        synchronized (this) {
                            while (inventory.size() >= Main.MAX_ITEM) {
                                System.out.println(Thread.currentThread().getName() + " Waiting!");
                                try {
                                    wait(); // 재고가 꽉 차있어서 재입고하지 않고 기다리는 중!
                                    Thread.sleep(333);
                                } catch (InterruptedException e) {
                                    e.printStackTrace();
                                }
                            }
                            // 재입고
                            inventory.add(item);
                            notify(); // 재입고 되었음을 고객에게 알려주기
                            System.out.println("Inventory 현황: " + inventory.toString());
                        }
                    }
                
                    public synchronized void sale(String itemName) {
                        while (inventory.size() == 0) {
                            System.out.println(Thread.currentThread().getName() + " Waiting!");
                            try {
                                wait(); // 재고가 없기 때문에 고객 대기중
                                Thread.sleep(333);
                            } catch (InterruptedException e) {
                                e.printStackTrace();
                            }
                        }
                
                        while (true) {
                            // 고객이 주문한 제품이 있는지 확인
                            for (int i = 0; i < inventory.size(); i++) {
                                if (itemName.equals(inventory.get(i))) {
                                    inventory.remove(itemName);
                                    notify(); // 제품 하나 팔렸으니 재입고 하라고 알려주기
                                    return; // 메서드 종료
                                }
                            }
                
                            // 고객이 찾는 제품이 없을 경우
                            try {
                                System.out.println(Thread.currentThread().getName() + " Waiting!");
                                wait();
                                Thread.sleep(333);
                            } catch (InterruptedException e) {
                                e.printStackTrace();
                            }
                        }
                
                    }
                }
                ```
                
            
    - Lock, Condition
        - Lock
            
            <aside>
            📌 synchronized 블럭으로 동기화하면 자동적으로 Lock이 걸리고 풀리지만, 같은 메서드 내에서만 Lock을 걸 수 있다는 제약이 있습니다.
            
            이런 제약을 해결하기 위해 Lock 클래스를 사용합니다.
            
            </aside>
            
            - ReentrantLock
                - 재진입 가능한 Lock, 가장 일반적인 배타 Lock
                - 특정 조건에서 Lock을 풀고, 나중에 다시 Lock을 얻어 임계영역으로 진입이 가능합니다.
                
                ```java
                public class MyClass {
                    private Object lock1 = new Object();
                    private Object lock2 = new Object();
                    
                    public void methodA() {
                        synchronized (lock1) {
                            methodB();
                        }
                    }
                    
                    public void methodB() {
                        synchronized (lock2) {
                            // do something
                            methodA();
                        }
                    }
                }
                ```
                
                - methodA는 **lock1**을 가지고, methodB는 **lock2**를 가집니다.
                - methodB에서 **methodA**를 호출하고 있으므로, **methodB**에서 **lock2**를 가진 상태에서 methodA를 호출하면 **lock1**을 가지려고 할 것입니다.
                - 그러나 이때, methodA에서 이미 lock1을 가지고 있으므로 lock2를 기다리는 상태가 되어 데드락이 발생할 가능성이 있습니다.
                - 하지만 ReentrantLock을 사용하면, 같은 스레드가 이미 락을 가지고 있더라도 락을 유지하며 계속 실행할 수 있기 때문에 데드락이 발생하지 않습니다.
                - 즉, ReentrantLock을 사용하면 코드의 유연성을 높일 수 있습니다.
            - ReentrantReadWriteLock
                - 읽기를 위한 Lock과 쓰기를 위한 Lock을 따로 제공합니다.
                - 읽기에는 공유적이고, 쓰기에는 베타적인 Lock입니다.
                - 읽기 Lock이 걸려있으면 다른 쓰레드들도 읽기 Lock을 중복으로 걸고 읽기를 수행할 수 있습니다. (read-only)
                - 읽기 Lock이 걸려있는 상태에서 쓰기 Lock을 거는 것은 허용되지 않습니다. (데이터 변경 방지)
            - StampedLock
                - ReentrantReadWriteLock에 낙관적인 Lock의 기능을 추가했습니다.
                    - 낙관적인 Lock : 데이터를 변경하기 전에 락을 걸지 않는 것을 말합니다. 낙관적인 락은 데이터 변경을 할 때 충돌이 일어날 가능성이 적은 상황에서 사용합니다.
                    - 낙관적인 락을 사용하면 읽기와 쓰기 작업 모두가 빠르게 처리됩니다. 쓰기 작업이 발생했을 때 데이터가 이미 변경된 경우 다시 읽기 작업을 수행하여 새로운 값을 읽어들이고, 변경 작업을 다시 수행합니다. 이러한 방식으로 쓰기 작업이 빈번하지 않은 경우에는 낙관적인 락을 사용하여 더 빠른 처리가 가능합니다.
                - 낙관적인 읽기 Lock은 쓰기 Lock에 의해 바로 해제 가능합니다.
                - 무조건 읽기 Lock을 걸지 않고, 쓰기와 읽기가 충돌할 때만 쓰기 후 읽기 Lock을 겁니다.
        - Condition
            
            <aside>
            📌 wait() & notify()의 문제점인 waiting pool 내 쓰레드를 구분하지 못한다는 것을 해결한 것이 Condition 입니다.
            
            **[추가 설명]**
            
            wait()과 notify()는 객체에 대한 모니터링 락(lock)을 이용하여 스레드를 대기시키고 깨웁니다. 그러나 wait()과 notify()는 **waiting pool 내에 대기중인 스레드를 구분하지 못하므로**, 특정 조건을 만족하는 스레드만 깨우기가 어렵습니다.
            
            이러한 문제를 해결하기 위해 JDK 5에서는 java.util.concurrent.locks 패키지에서 Condition 인터페이스를 제공합니다. Condition은 waiting pool 내의 스레드를 분리하여 특정 조건이 만족될 때만 깨우도록 할 수 있으며, ReentrantLock 클래스와 함께 사용됩니다. 따라서 Condition을 사용하면 wait()과 notify()의 문제점을 보완할 수 있습니다.
            
            </aside>
            
            - `wait()` & `notify()` 대신 Condition의 `await()` & `signal()` 을 사용합니다.
            - 아래 코드와 같이 Condition 을 만들어서 대기줄(waiting pool)을 사용 할 수 있습니다.
            
            ```java
            private ReentrantLock lock = new ReentrantLock();
            
            // lock으로 condition 생성
            private Condition condition1 = lock.newCondition();
            private Condition condition2 = lock.newCondition();
            
            private ArrayList<String> tasks = new ArrayList<>();
            
            // 작업 메서드
            public void addMethod(String task) {
            		lock.lock(); // 임계영역 시작
            
            		try {
            			while(tasks.size() >= MAX_TASK) {
            					String name = Thread.currentThread().getName();
            					System.out.println(name+" is waiting.");
            					try {
            						condition1.await(); // wait(); condition1 쓰레드를 기다리게 합니다.
            						Thread.sleep(500);
            					} catch(InterruptedException e) {}	
            			}
            
            			tasks.add(task);
            			condition2.signal(); // notify();  기다리고 있는 condition2를 깨워줍니다.
            			System.out.println("Tasks:" + tasks.toString());
            		} finally {
            			lock.unlock(); // 임계영역 끝
            		}
            	}
            ```
            